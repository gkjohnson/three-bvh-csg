import{n as fe,V as R,j as K,as as $t,at as It,au as Le,av as $n,r as J,T as X,d as Et,l as vn,a as Ge,aw as Hn,F as Ye,ax as En,ay as yt,M as Xn,az as Ue,aA as Gn,aB as On}from"./TriangleSplitter-ByAGyBL2.js";const In=0,jn=1,Wn=2,Ze=2,he=1.25,Ke=1,Ft=32,pe=65535,qn=Math.pow(2,-24),ge=Symbol("SKIP_GENERATION");function Yn(n){return n.index?n.index.count:n.attributes.position.count}function Mt(n){return Yn(n)/3}function Zn(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Kn(n,t){if(!n.index){const e=n.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Zn(e,i);n.setIndex(new fe(s,1));for(let o=0;o<e;o++)s[o]=o}}function Mn(n,t){const e=Mt(n),i=t||n.drawRange,s=i.start/3,o=(i.start+i.count)/3,c=Math.max(0,s),a=Math.min(e,o)-c;return[{offset:Math.floor(c),count:Math.floor(a)}]}function Pn(n,t){if(!n.groups||!n.groups.length)return Mn(n,t);const e=[],i=new Set,s=t||n.drawRange,o=s.start/3,c=(s.start+s.count)/3;for(const r of n.groups){const f=r.start/3,l=(r.start+r.count)/3;i.add(Math.max(o,f)),i.add(Math.min(c,l))}const a=Array.from(i.values()).sort((r,f)=>r-f);for(let r=0;r<a.length-1;r++){const f=a[r],l=a[r+1];e.push({offset:Math.floor(f),count:Math.floor(l-f)})}return e}function Jn(n,t){const e=Mt(n),i=Pn(n,t).sort((c,a)=>c.offset-a.offset),s=i[i.length-1];s.count=Math.min(e-s.offset,s.count);let o=0;return i.forEach(({count:c})=>o+=c),e!==o}function ye(n,t,e,i,s){let o=1/0,c=1/0,a=1/0,r=-1/0,f=-1/0,l=-1/0,p=1/0,u=1/0,d=1/0,w=-1/0,B=-1/0,x=-1/0;for(let g=t*6,h=(t+e)*6;g<h;g+=6){const y=n[g+0],m=n[g+1],A=y-m,T=y+m;A<o&&(o=A),T>r&&(r=T),y<p&&(p=y),y>w&&(w=y);const b=n[g+2],S=n[g+3],E=b-S,M=b+S;E<c&&(c=E),M>f&&(f=M),b<u&&(u=b),b>B&&(B=b);const P=n[g+4],_=n[g+5],I=P-_,C=P+_;I<a&&(a=I),C>l&&(l=C),P<d&&(d=P),P>x&&(x=P)}i[0]=o,i[1]=c,i[2]=a,i[3]=r,i[4]=f,i[5]=l,s[0]=p,s[1]=u,s[2]=d,s[3]=w,s[4]=B,s[5]=x}function Qn(n,t=null,e=null,i=null){const s=n.attributes.position,o=n.index?n.index.array:null,c=Mt(n),a=s.normalized;let r;t===null?(r=new Float32Array(c*6),e=0,i=c):(r=t,e=e||0,i=i||c);const f=s.array,l=s.offset||0;let p=3;s.isInterleavedBufferAttribute&&(p=s.data.stride);const u=["getX","getY","getZ"];for(let d=e;d<e+i;d++){const w=d*3,B=d*6;let x=w+0,g=w+1,h=w+2;o&&(x=o[x],g=o[g],h=o[h]),a||(x=x*p+l,g=g*p+l,h=h*p+l);for(let y=0;y<3;y++){let m,A,T;a?(m=s[u[y]](x),A=s[u[y]](g),T=s[u[y]](h)):(m=f[x+y],A=f[g+y],T=f[h+y]);let b=m;A<b&&(b=A),T<b&&(b=T);let S=m;A>S&&(S=A),T>S&&(S=T);const E=(S-b)/2,M=y*2;r[B+M+0]=b+E,r[B+M+1]=E+(Math.abs(b)+E)*qn}}return r}function N(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Je(n){let t=-1,e=-1/0;for(let i=0;i<3;i++){const s=n[i+3]-n[i];s>e&&(e=s,t=i)}return t}function Qe(n,t){t.set(n)}function tn(n,t,e){let i,s;for(let o=0;o<3;o++){const c=o+3;i=n[o],s=t[o],e[o]=i<s?i:s,i=n[c],s=t[c],e[c]=i>s?i:s}}function vt(n,t,e){for(let i=0;i<3;i++){const s=t[n+2*i],o=t[n+2*i+1],c=s-o,a=s+o;c<e[i]&&(e[i]=c),a>e[i+3]&&(e[i+3]=a)}}function Pt(n){const t=n[3]-n[0],e=n[4]-n[1],i=n[5]-n[2];return 2*(t*e+e*i+i*t)}const tt=32,ti=(n,t)=>n.candidate-t.candidate,et=new Array(tt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Ht=new Float32Array(6);function ei(n,t,e,i,s,o){let c=-1,a=0;if(o===In)c=Je(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(o===jn)c=Je(n),c!==-1&&(a=ni(e,i,s,c));else if(o===Wn){const r=Pt(n);let f=he*s;const l=i*6,p=(i+s)*6;for(let u=0;u<3;u++){const d=t[u],x=(t[u+3]-d)/tt;if(s<tt/4){const g=[...et];g.length=s;let h=0;for(let m=l;m<p;m+=6,h++){const A=g[h];A.candidate=e[m+2*u],A.count=0;const{bounds:T,leftCacheBounds:b,rightCacheBounds:S}=A;for(let E=0;E<3;E++)S[E]=1/0,S[E+3]=-1/0,b[E]=1/0,b[E+3]=-1/0,T[E]=1/0,T[E+3]=-1/0;vt(m,e,T)}g.sort(ti);let y=s;for(let m=0;m<y;m++){const A=g[m];for(;m+1<y&&g[m+1].candidate===A.candidate;)g.splice(m+1,1),y--}for(let m=l;m<p;m+=6){const A=e[m+2*u];for(let T=0;T<y;T++){const b=g[T];A>=b.candidate?vt(m,e,b.rightCacheBounds):(vt(m,e,b.leftCacheBounds),b.count++)}}for(let m=0;m<y;m++){const A=g[m],T=A.count,b=s-A.count,S=A.leftCacheBounds,E=A.rightCacheBounds;let M=0;T!==0&&(M=Pt(S)/r);let P=0;b!==0&&(P=Pt(E)/r);const _=Ke+he*(M*T+P*b);_<f&&(c=u,f=_,a=A.candidate)}}else{for(let y=0;y<tt;y++){const m=et[y];m.count=0,m.candidate=d+x+y*x;const A=m.bounds;for(let T=0;T<3;T++)A[T]=1/0,A[T+3]=-1/0}for(let y=l;y<p;y+=6){let T=~~((e[y+2*u]-d)/x);T>=tt&&(T=tt-1);const b=et[T];b.count++,vt(y,e,b.bounds)}const g=et[tt-1];Qe(g.bounds,g.rightCacheBounds);for(let y=tt-2;y>=0;y--){const m=et[y],A=et[y+1];tn(m.bounds,A.rightCacheBounds,m.rightCacheBounds)}let h=0;for(let y=0;y<tt-1;y++){const m=et[y],A=m.count,T=m.bounds,S=et[y+1].rightCacheBounds;A!==0&&(h===0?Qe(T,Ht):tn(T,Ht,Ht)),h+=A;let E=0,M=0;h!==0&&(E=Pt(Ht)/r);const P=s-h;P!==0&&(M=Pt(S)/r);const _=Ke+he*(E*h+M*P);_<f&&(c=u,f=_,a=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:c,pos:a}}function ni(n,t,e,i){let s=0;for(let o=t,c=t+e;o<c;o++)s+=n[o*6+i*2];return s/e}class me{constructor(){this.boundingData=new Float32Array(6)}}function ii(n,t,e,i,s,o){let c=i,a=i+s-1;const r=o.pos,f=o.axis*2;for(;;){for(;c<=a&&e[c*6+f]<r;)c++;for(;c<=a&&e[a*6+f]>=r;)a--;if(c<a){for(let l=0;l<3;l++){let p=t[c*3+l];t[c*3+l]=t[a*3+l],t[a*3+l]=p}for(let l=0;l<6;l++){let p=e[c*6+l];e[c*6+l]=e[a*6+l],e[a*6+l]=p}c++,a--}else return c}}function si(n,t,e,i,s,o){let c=i,a=i+s-1;const r=o.pos,f=o.axis*2;for(;;){for(;c<=a&&e[c*6+f]<r;)c++;for(;c<=a&&e[a*6+f]>=r;)a--;if(c<a){let l=n[c];n[c]=n[a],n[a]=l;for(let p=0;p<6;p++){let u=e[c*6+p];e[c*6+p]=e[a*6+p],e[a*6+p]=u}c++,a--}else return c}}function $(n,t){return t[n+15]===65535}function v(n,t){return t[n+6]}function G(n,t){return t[n+14]}function O(n){return n+8}function j(n,t){return t[n+6]}function Cn(n,t){return t[n+7]}let zn,Dt,re,Rn;const ri=Math.pow(2,32);function Ne(n){return"count"in n?1:1+Ne(n.left)+Ne(n.right)}function oi(n,t,e){return zn=new Float32Array(e),Dt=new Uint32Array(e),re=new Uint16Array(e),Rn=new Uint8Array(e),De(n,t)}function De(n,t){const e=n/4,i=n/2,s="count"in t,o=t.boundingData;for(let c=0;c<6;c++)zn[e+c]=o[c];if(s)if(t.buffer){const c=t.buffer;Rn.set(new Uint8Array(c),n);for(let a=n,r=n+c.byteLength;a<r;a+=Ft){const f=a/2;$(f,re)||(Dt[a/4+6]+=e)}return n+c.byteLength}else{const c=t.offset,a=t.count;return Dt[e+6]=c,re[i+14]=a,re[i+15]=pe,n+Ft}else{const c=t.left,a=t.right,r=t.splitAxis;let f;if(f=De(n+Ft,c),f/4>ri)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Dt[e+6]=f/4,f=De(f,a),Dt[e+7]=r,f}}function ci(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,i=e>2**16,s=i?4:2,o=t?new SharedArrayBuffer(e*s):new ArrayBuffer(e*s),c=i?new Uint32Array(o):new Uint16Array(o);for(let a=0,r=c.length;a<r;a++)c[a]=a;return c}function ai(n,t,e,i,s){const{maxDepth:o,verbose:c,maxLeafTris:a,strategy:r,onProgress:f,indirect:l}=s,p=n._indirectBuffer,u=n.geometry,d=u.index?u.index.array:null,w=l?si:ii,B=Mt(u),x=new Float32Array(6);let g=!1;const h=new me;return ye(t,e,i,h.boundingData,x),m(h,e,i,x),h;function y(A){f&&f(A/B)}function m(A,T,b,S=null,E=0){if(!g&&E>=o&&(g=!0,c&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),b<=a||E>=o)return y(T+b),A.offset=T,A.count=b,A;const M=ei(A.boundingData,S,t,T,b,r);if(M.axis===-1)return y(T+b),A.offset=T,A.count=b,A;const P=w(p,d,t,T,b,M);if(P===T||P===T+b)y(T+b),A.offset=T,A.count=b;else{A.splitAxis=M.axis;const _=new me,I=T,C=P-T;A.left=_,ye(t,I,C,_.boundingData,x),m(_,I,C,x,E+1);const z=new me,L=P,F=b-C;A.right=z,ye(t,L,F,z.boundingData,x),m(z,L,F,x,E+1)}return A}}function li(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=ci(e,t.useSharedArrayBuffer),Jn(e,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Kn(e,t);const i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Qn(e),o=t.indirect?Mn(e,t.range):Pn(e,t.range);n._roots=o.map(c=>{const a=ai(n,s,c.offset,c.count,t),r=Ne(a),f=new i(Ft*r);return oi(0,a,f),f})}class V{constructor(t,e,i){this.isOrientedBox=!0,this.min=new R,this.max=new R,this.matrix=new K,this.invMatrix=new K,this.points=new Array(8).fill().map(()=>new R),this.satAxes=new Array(3).fill().map(()=>new R),this.satBounds=new Array(3).fill().map(()=>new $t),this.alignedSatBounds=new Array(3).fill().map(()=>new $t),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),i&&this.matrix.copy(i)}set(t,e,i){this.min.copy(t),this.max.copy(e),this.matrix.copy(i),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}V.prototype.update=(function(){return function(){const t=this.matrix,e=this.min,i=this.max,s=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const u=1*f|2*l|4*p,d=s[u];d.x=f?i.x:e.x,d.y=l?i.y:e.y,d.z=p?i.z:e.z,d.applyMatrix4(t)}const o=this.satBounds,c=this.satAxes,a=s[0];for(let f=0;f<3;f++){const l=c[f],p=o[f],u=1<<f,d=s[u];l.subVectors(a,d),p.setFromPoints(l,s)}const r=this.alignedSatBounds;r[0].setFromPointsField(s,"x"),r[1].setFromPointsField(s,"y"),r[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();V.prototype.intersectsBox=(function(){const n=new $t;return function(e){this.needsUpdate&&this.update();const i=e.min,s=e.max,o=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(n.min=i.x,n.max=s.x,a[0].isSeparated(n)||(n.min=i.y,n.max=s.y,a[1].isSeparated(n))||(n.min=i.z,n.max=s.z,a[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const f=c[r],l=o[r];if(n.setFromBox(f,e),l.isSeparated(n))return!1}return!0}})();V.prototype.intersectsTriangle=(function(){const n=new It,t=new Array(3),e=new $t,i=new $t,s=new R;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(n.copy(c),n.update(),c=n);const a=this.satBounds,r=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let u=0;u<3;u++){const d=a[u],w=r[u];if(e.setFromPoints(w,t),d.isSeparated(e))return!1}const f=c.satBounds,l=c.satAxes,p=this.points;for(let u=0;u<3;u++){const d=f[u],w=l[u];if(e.setFromPoints(w,p),d.isSeparated(e))return!1}for(let u=0;u<3;u++){const d=r[u];for(let w=0;w<4;w++){const B=l[w];if(s.crossVectors(d,B),e.setFromPoints(s,t),i.setFromPoints(s,p),e.isSeparated(i))return!1}}return!0}})();V.prototype.closestPointToPoint=(function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}})();V.prototype.distanceToPoint=(function(){const n=new R;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}})();V.prototype.distanceToBox=(function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new Le),e=new Array(12).fill().map(()=>new Le),i=new R,s=new R;return function(c,a=0,r=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(r||f)&&(c.getCenter(s),this.closestPointToPoint(s,i),c.closestPointToPoint(i,s),r&&r.copy(i),f&&f.copy(s)),0;const l=a*a,p=c.min,u=c.max,d=this.points;let w=1/0;for(let x=0;x<8;x++){const g=d[x];s.copy(g).clamp(p,u);const h=g.distanceToSquared(s);if(h<w&&(w=h,r&&r.copy(g),f&&f.copy(s),h<l))return Math.sqrt(h)}let B=0;for(let x=0;x<3;x++)for(let g=0;g<=1;g++)for(let h=0;h<=1;h++){const y=(x+1)%3,m=(x+2)%3,A=g<<y|h<<m,T=1<<x|g<<y|h<<m,b=d[A],S=d[T];t[B].set(b,S);const M=n[x],P=n[y],_=n[m],I=e[B],C=I.start,z=I.end;C[M]=p[M],C[P]=g?p[P]:u[P],C[_]=h?p[_]:u[P],z[M]=u[M],z[P]=g?p[P]:u[P],z[_]=h?p[_]:u[P],B++}for(let x=0;x<=1;x++)for(let g=0;g<=1;g++)for(let h=0;h<=1;h++){s.x=x?u.x:p.x,s.y=g?u.y:p.y,s.z=h?u.z:p.z,this.closestPointToPoint(s,i);const y=s.distanceToSquared(i);if(y<w&&(w=y,r&&r.copy(i),f&&f.copy(s),y<l))return Math.sqrt(y)}for(let x=0;x<12;x++){const g=t[x];for(let h=0;h<12;h++){const y=e[h];$n(g,y,i,s);const m=i.distanceToSquared(s);if(m<w&&(w=m,r&&r.copy(i),f&&f.copy(s),m<l))return Math.sqrt(m)}}return Math.sqrt(w)}})();class Oe{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ui extends Oe{constructor(){super(()=>new It)}}const W=new ui;class fi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=i=>{e&&t.push(e),e=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const U=new fi;let st,_t;const At=[],Xt=new Oe(()=>new J);function pi(n,t,e,i,s,o){st=Xt.getPrimitive(),_t=Xt.getPrimitive(),At.push(st,_t),U.setBuffer(n._roots[t]);const c=Fe(0,n.geometry,e,i,s,o);U.clearBuffer(),Xt.releasePrimitive(st),Xt.releasePrimitive(_t),At.pop(),At.pop();const a=At.length;return a>0&&(_t=At[a-1],st=At[a-2]),c}function Fe(n,t,e,i,s=null,o=0,c=0){const{float32Array:a,uint16Array:r,uint32Array:f}=U;let l=n*2;if($(l,r)){const u=v(n,f),d=G(l,r);return N(n,a,st),i(u,d,!1,c,o+n,st)}else{let M=function(_){const{uint16Array:I,uint32Array:C}=U;let z=_*2;for(;!$(z,I);)_=O(_),z=_*2;return v(_,C)},P=function(_){const{uint16Array:I,uint32Array:C}=U;let z=_*2;for(;!$(z,I);)_=j(_,C),z=_*2;return v(_,C)+G(z,I)};const u=O(n),d=j(n,f);let w=u,B=d,x,g,h,y;if(s&&(h=st,y=_t,N(w,a,h),N(B,a,y),x=s(h),g=s(y),g<x)){w=d,B=u;const _=x;x=g,g=_,h=y}h||(h=st,N(w,a,h));const m=$(w*2,r),A=e(h,m,x,c+1,o+w);let T;if(A===Ze){const _=M(w),C=P(w)-_;T=i(_,C,!0,c+1,o+w,h)}else T=A&&Fe(w,t,e,i,s,o,c+1);if(T)return!0;y=_t,N(B,a,y);const b=$(B*2,r),S=e(y,b,g,c+1,o+B);let E;if(S===Ze){const _=M(B),C=P(B)-_;E=i(_,C,!0,c+1,o+B,y)}else E=S&&Fe(B,t,e,i,s,o,c+1);return!!E}}const Ct=new R,Ae=new R;function di(n,t,e={},i=0,s=1/0){const o=i*i,c=s*s;let a=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(Ct.copy(t).clamp(l.min,l.max),Ct.distanceToSquared(t)),intersectsBounds:(l,p,u)=>u<a&&u<c,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,Ct);const u=t.distanceToSquared(Ct);return u<a&&(Ae.copy(Ct),a=u,r=p),u<o}}),a===1/0)return null;const f=Math.sqrt(a);return e.point?e.point.copy(Ae):e.point=Ae.clone(),e.distance=f,e.faceIndex=r,e}const hi=parseInt(Hn)>=169,at=new R,lt=new R,ut=new R,Gt=new Et,Ot=new Et,jt=new Et,en=new R,nn=new R,sn=new R,zt=new R;function gi(n,t,e,i,s,o,c,a){let r;if(o===vn?r=n.intersectTriangle(i,e,t,!0,s):r=n.intersectTriangle(t,e,i,o!==Ge,s),r===null)return null;const f=n.origin.distanceTo(s);return f<c||f>a?null:{distance:f,point:s.clone()}}function yi(n,t,e,i,s,o,c,a,r,f,l){at.fromBufferAttribute(t,o),lt.fromBufferAttribute(t,c),ut.fromBufferAttribute(t,a);const p=gi(n,at,lt,ut,zt,r,f,l);if(p){const u=new R;X.getBarycoord(zt,at,lt,ut,u),i&&(Gt.fromBufferAttribute(i,o),Ot.fromBufferAttribute(i,c),jt.fromBufferAttribute(i,a),p.uv=X.getInterpolation(zt,at,lt,ut,Gt,Ot,jt,new Et)),s&&(Gt.fromBufferAttribute(s,o),Ot.fromBufferAttribute(s,c),jt.fromBufferAttribute(s,a),p.uv1=X.getInterpolation(zt,at,lt,ut,Gt,Ot,jt,new Et)),e&&(en.fromBufferAttribute(e,o),nn.fromBufferAttribute(e,c),sn.fromBufferAttribute(e,a),p.normal=X.getInterpolation(zt,at,lt,ut,en,nn,sn,new R),p.normal.dot(n.direction)>0&&p.normal.multiplyScalar(-1));const d={a:o,b:c,c:a,normal:new R,materialIndex:0};X.getNormal(at,lt,ut,d.normal),p.face=d,p.faceIndex=o,hi&&(p.barycoord=u)}return p}function de(n,t,e,i,s,o,c){const a=i*3;let r=a+0,f=a+1,l=a+2;const p=n.index;n.index&&(r=p.getX(r),f=p.getX(f),l=p.getX(l));const{position:u,normal:d,uv:w,uv1:B}=n.attributes,x=yi(e,u,d,w,B,r,f,l,t,o,c);return x?(x.faceIndex=i,s&&s.push(x),x):null}function D(n,t,e,i){const s=n.a,o=n.b,c=n.c;let a=t,r=t+1,f=t+2;e&&(a=e.getX(a),r=e.getX(r),f=e.getX(f)),s.x=i.getX(a),s.y=i.getY(a),s.z=i.getZ(a),o.x=i.getX(r),o.y=i.getY(r),o.z=i.getZ(r),c.x=i.getX(f),c.y=i.getY(f),c.z=i.getZ(f)}function mi(n,t,e,i,s,o,c,a){const{geometry:r,_indirectBuffer:f}=n;for(let l=i,p=i+s;l<p;l++)de(r,t,e,l,o,c,a)}function Ai(n,t,e,i,s,o,c){const{geometry:a,_indirectBuffer:r}=n;let f=1/0,l=null;for(let p=i,u=i+s;p<u;p++){let d;d=de(a,t,e,p,null,o,c),d&&d.distance<f&&(l=d,f=d.distance)}return l}function xi(n,t,e,i,s,o,c){const{geometry:a}=e,{index:r}=a,f=a.attributes.position;for(let l=n,p=t+n;l<p;l++){let u;if(u=l,D(c,u*3,r,f),c.needsUpdate=!0,i(c,u,s,o))return!0}return!1}function wi(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,i=e.index?e.index.array:null,s=e.attributes.position;let o,c,a,r,f=0;const l=n._roots;for(let u=0,d=l.length;u<d;u++)o=l[u],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),p(0,f),f+=o.byteLength;function p(u,d,w=!1){const B=u*2;if(a[B+15]===pe){const g=c[u+6],h=a[B+14];let y=1/0,m=1/0,A=1/0,T=-1/0,b=-1/0,S=-1/0;for(let E=3*g,M=3*(g+h);E<M;E++){let P=i[E];const _=s.getX(P),I=s.getY(P),C=s.getZ(P);_<y&&(y=_),_>T&&(T=_),I<m&&(m=I),I>b&&(b=I),C<A&&(A=C),C>S&&(S=C)}return r[u+0]!==y||r[u+1]!==m||r[u+2]!==A||r[u+3]!==T||r[u+4]!==b||r[u+5]!==S?(r[u+0]=y,r[u+1]=m,r[u+2]=A,r[u+3]=T,r[u+4]=b,r[u+5]=S,!0):!1}else{const g=u+8,h=c[u+6],y=g+d,m=h+d;let A=w,T=!1,b=!1;t?A||(T=t.has(y),b=t.has(m),A=!T&&!b):(T=!0,b=!0);const S=A||T,E=A||b;let M=!1;S&&(M=p(g,d,A));let P=!1;E&&(P=p(h,d,A));const _=M||P;if(_)for(let I=0;I<3;I++){const C=g+I,z=h+I,L=r[C],F=r[C+3],mt=r[z],ct=r[z+3];r[u+I]=L<mt?L:mt,r[u+I+3]=F>ct?F:ct}return _}}}function ot(n,t,e,i,s){let o,c,a,r,f,l;const p=1/e.direction.x,u=1/e.direction.y,d=1/e.direction.z,w=e.origin.x,B=e.origin.y,x=e.origin.z;let g=t[n],h=t[n+3],y=t[n+1],m=t[n+3+1],A=t[n+2],T=t[n+3+2];return p>=0?(o=(g-w)*p,c=(h-w)*p):(o=(h-w)*p,c=(g-w)*p),u>=0?(a=(y-B)*u,r=(m-B)*u):(a=(m-B)*u,r=(y-B)*u),o>r||a>c||((a>o||isNaN(o))&&(o=a),(r<c||isNaN(c))&&(c=r),d>=0?(f=(A-x)*d,l=(T-x)*d):(f=(T-x)*d,l=(A-x)*d),o>l||f>c)?!1:((f>o||o!==o)&&(o=f),(l<c||c!==c)&&(c=l),o<=s&&c>=i)}function bi(n,t,e,i,s,o,c,a){const{geometry:r,_indirectBuffer:f}=n;for(let l=i,p=i+s;l<p;l++){let u=f?f[l]:l;de(r,t,e,u,o,c,a)}}function Bi(n,t,e,i,s,o,c){const{geometry:a,_indirectBuffer:r}=n;let f=1/0,l=null;for(let p=i,u=i+s;p<u;p++){let d;d=de(a,t,e,r?r[p]:p,null,o,c),d&&d.distance<f&&(l=d,f=d.distance)}return l}function Ti(n,t,e,i,s,o,c){const{geometry:a}=e,{index:r}=a,f=a.attributes.position;for(let l=n,p=t+n;l<p;l++){let u;if(u=e.resolveTriangleIndex(l),D(c,u*3,r,f),c.needsUpdate=!0,i(c,u,s,o))return!0}return!1}function Si(n,t,e,i,s,o,c){U.setBuffer(n._roots[t]),ke(0,n,e,i,s,o,c),U.clearBuffer()}function ke(n,t,e,i,s,o,c){const{float32Array:a,uint16Array:r,uint32Array:f}=U,l=n*2;if($(l,r)){const u=v(n,f),d=G(l,r);mi(t,e,i,u,d,s,o,c)}else{const u=O(n);ot(u,a,i,o,c)&&ke(u,t,e,i,s,o,c);const d=j(n,f);ot(d,a,i,o,c)&&ke(d,t,e,i,s,o,c)}}const _i=["x","y","z"];function Ei(n,t,e,i,s,o){U.setBuffer(n._roots[t]);const c=Ve(0,n,e,i,s,o);return U.clearBuffer(),c}function Ve(n,t,e,i,s,o){const{float32Array:c,uint16Array:a,uint32Array:r}=U;let f=n*2;if($(f,a)){const p=v(n,r),u=G(f,a);return Ai(t,e,i,p,u,s,o)}else{const p=Cn(n,r),u=_i[p],w=i.direction[u]>=0;let B,x;w?(B=O(n),x=j(n,r)):(B=j(n,r),x=O(n));const h=ot(B,c,i,s,o)?Ve(B,t,e,i,s,o):null;if(h){const A=h.point[u];if(w?A<=c[x+p]:A>=c[x+p+3])return h}const m=ot(x,c,i,s,o)?Ve(x,t,e,i,s,o):null;return h&&m?h.distance<=m.distance?h:m:h||m||null}}const Wt=new J,xt=new It,wt=new It,Rt=new K,rn=new V,qt=new V;function Ii(n,t,e,i){U.setBuffer(n._roots[t]);const s=$e(0,n,e,i);return U.clearBuffer(),s}function $e(n,t,e,i,s=null){const{float32Array:o,uint16Array:c,uint32Array:a}=U;let r=n*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),rn.set(e.boundingBox.min,e.boundingBox.max,i),s=rn),$(r,c)){const l=t.geometry,p=l.index,u=l.attributes.position,d=e.index,w=e.attributes.position,B=v(n,a),x=G(r,c);if(Rt.copy(i).invert(),e.boundsTree)return N(n,o,qt),qt.matrix.copy(Rt),qt.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:h=>qt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(i),h.b.applyMatrix4(i),h.c.applyMatrix4(i),h.needsUpdate=!0;for(let y=B*3,m=(x+B)*3;y<m;y+=3)if(D(wt,y,p,u),wt.needsUpdate=!0,h.intersectsTriangle(wt))return!0;return!1}});for(let g=B*3,h=(x+B)*3;g<h;g+=3){D(xt,g,p,u),xt.a.applyMatrix4(Rt),xt.b.applyMatrix4(Rt),xt.c.applyMatrix4(Rt),xt.needsUpdate=!0;for(let y=0,m=d.count;y<m;y+=3)if(D(wt,y,d,w),wt.needsUpdate=!0,xt.intersectsTriangle(wt))return!0}}else{const l=n+8,p=a[n+6];return N(l,o,Wt),!!(s.intersectsBox(Wt)&&$e(l,t,e,i,s)||(N(p,o,Wt),s.intersectsBox(Wt)&&$e(p,t,e,i,s)))}}const Yt=new K,xe=new V,Lt=new V,Mi=new R,Pi=new R,Ci=new R,zi=new R;function Ri(n,t,e,i={},s={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),xe.set(t.boundingBox.min,t.boundingBox.max,e),xe.needsUpdate=!0;const a=n.geometry,r=a.attributes.position,f=a.index,l=t.attributes.position,p=t.index,u=W.getPrimitive(),d=W.getPrimitive();let w=Mi,B=Pi,x=null,g=null;s&&(x=Ci,g=zi);let h=1/0,y=null,m=null;return Yt.copy(e).invert(),Lt.matrix.copy(Yt),n.shapecast({boundsTraverseOrder:A=>xe.distanceToBox(A),intersectsBounds:(A,T,b)=>b<h&&b<c?(T&&(Lt.min.copy(A.min),Lt.max.copy(A.max),Lt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:S=>Lt.distanceToBox(S),intersectsBounds:(S,E,M)=>M<h&&M<c,intersectsRange:(S,E)=>{for(let M=S,P=S+E;M<P;M++){D(d,3*M,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let _=A,I=A+T;_<I;_++){D(u,3*_,f,r),u.needsUpdate=!0;const C=u.distanceToTriangle(d,w,x);if(C<h&&(B.copy(w),g&&g.copy(x),h=C,y=_,m=M),C<o)return!0}}}});{const b=Mt(t);for(let S=0,E=b;S<E;S++){D(d,3*S,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let M=A,P=A+T;M<P;M++){D(u,3*M,f,r),u.needsUpdate=!0;const _=u.distanceToTriangle(d,w,x);if(_<h&&(B.copy(w),g&&g.copy(x),h=_,y=M,m=S),_<o)return!0}}}}}),W.releasePrimitive(u),W.releasePrimitive(d),h===1/0?null:(i.point?i.point.copy(B):i.point=B.clone(),i.distance=h,i.faceIndex=y,s&&(s.point?s.point.copy(g):s.point=g.clone(),s.point.applyMatrix4(Yt),B.applyMatrix4(Yt),s.distance=B.sub(s.point).length(),s.faceIndex=m),i)}function Li(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,i=e.index?e.index.array:null,s=e.attributes.position;let o,c,a,r,f=0;const l=n._roots;for(let u=0,d=l.length;u<d;u++)o=l[u],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),p(0,f),f+=o.byteLength;function p(u,d,w=!1){const B=u*2;if(a[B+15]===pe){const g=c[u+6],h=a[B+14];let y=1/0,m=1/0,A=1/0,T=-1/0,b=-1/0,S=-1/0;for(let E=g,M=g+h;E<M;E++){const P=3*n.resolveTriangleIndex(E);for(let _=0;_<3;_++){let I=P+_;I=i?i[I]:I;const C=s.getX(I),z=s.getY(I),L=s.getZ(I);C<y&&(y=C),C>T&&(T=C),z<m&&(m=z),z>b&&(b=z),L<A&&(A=L),L>S&&(S=L)}}return r[u+0]!==y||r[u+1]!==m||r[u+2]!==A||r[u+3]!==T||r[u+4]!==b||r[u+5]!==S?(r[u+0]=y,r[u+1]=m,r[u+2]=A,r[u+3]=T,r[u+4]=b,r[u+5]=S,!0):!1}else{const g=u+8,h=c[u+6],y=g+d,m=h+d;let A=w,T=!1,b=!1;t?A||(T=t.has(y),b=t.has(m),A=!T&&!b):(T=!0,b=!0);const S=A||T,E=A||b;let M=!1;S&&(M=p(g,d,A));let P=!1;E&&(P=p(h,d,A));const _=M||P;if(_)for(let I=0;I<3;I++){const C=g+I,z=h+I,L=r[C],F=r[C+3],mt=r[z],ct=r[z+3];r[u+I]=L<mt?L:mt,r[u+I+3]=F>ct?F:ct}return _}}}function Ui(n,t,e,i,s,o,c){U.setBuffer(n._roots[t]),ve(0,n,e,i,s,o,c),U.clearBuffer()}function ve(n,t,e,i,s,o,c){const{float32Array:a,uint16Array:r,uint32Array:f}=U,l=n*2;if($(l,r)){const u=v(n,f),d=G(l,r);bi(t,e,i,u,d,s,o,c)}else{const u=O(n);ot(u,a,i,o,c)&&ve(u,t,e,i,s,o,c);const d=j(n,f);ot(d,a,i,o,c)&&ve(d,t,e,i,s,o,c)}}const Ni=["x","y","z"];function Di(n,t,e,i,s,o){U.setBuffer(n._roots[t]);const c=He(0,n,e,i,s,o);return U.clearBuffer(),c}function He(n,t,e,i,s,o){const{float32Array:c,uint16Array:a,uint32Array:r}=U;let f=n*2;if($(f,a)){const p=v(n,r),u=G(f,a);return Bi(t,e,i,p,u,s,o)}else{const p=Cn(n,r),u=Ni[p],w=i.direction[u]>=0;let B,x;w?(B=O(n),x=j(n,r)):(B=j(n,r),x=O(n));const h=ot(B,c,i,s,o)?He(B,t,e,i,s,o):null;if(h){const A=h.point[u];if(w?A<=c[x+p]:A>=c[x+p+3])return h}const m=ot(x,c,i,s,o)?He(x,t,e,i,s,o):null;return h&&m?h.distance<=m.distance?h:m:h||m||null}}const Zt=new J,bt=new It,Bt=new It,Ut=new K,on=new V,Kt=new V;function Fi(n,t,e,i){U.setBuffer(n._roots[t]);const s=Xe(0,n,e,i);return U.clearBuffer(),s}function Xe(n,t,e,i,s=null){const{float32Array:o,uint16Array:c,uint32Array:a}=U;let r=n*2;if(s===null&&(e.boundingBox||e.computeBoundingBox(),on.set(e.boundingBox.min,e.boundingBox.max,i),s=on),$(r,c)){const l=t.geometry,p=l.index,u=l.attributes.position,d=e.index,w=e.attributes.position,B=v(n,a),x=G(r,c);if(Ut.copy(i).invert(),e.boundsTree)return N(n,o,Kt),Kt.matrix.copy(Ut),Kt.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:h=>Kt.intersectsBox(h),intersectsTriangle:h=>{h.a.applyMatrix4(i),h.b.applyMatrix4(i),h.c.applyMatrix4(i),h.needsUpdate=!0;for(let y=B,m=x+B;y<m;y++)if(D(Bt,3*t.resolveTriangleIndex(y),p,u),Bt.needsUpdate=!0,h.intersectsTriangle(Bt))return!0;return!1}});for(let g=B,h=x+B;g<h;g++){const y=t.resolveTriangleIndex(g);D(bt,3*y,p,u),bt.a.applyMatrix4(Ut),bt.b.applyMatrix4(Ut),bt.c.applyMatrix4(Ut),bt.needsUpdate=!0;for(let m=0,A=d.count;m<A;m+=3)if(D(Bt,m,d,w),Bt.needsUpdate=!0,bt.intersectsTriangle(Bt))return!0}}else{const l=n+8,p=a[n+6];return N(l,o,Zt),!!(s.intersectsBox(Zt)&&Xe(l,t,e,i,s)||(N(p,o,Zt),s.intersectsBox(Zt)&&Xe(p,t,e,i,s)))}}const Jt=new K,we=new V,Nt=new V,ki=new R,Vi=new R,$i=new R,vi=new R;function Hi(n,t,e,i={},s={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),we.set(t.boundingBox.min,t.boundingBox.max,e),we.needsUpdate=!0;const a=n.geometry,r=a.attributes.position,f=a.index,l=t.attributes.position,p=t.index,u=W.getPrimitive(),d=W.getPrimitive();let w=ki,B=Vi,x=null,g=null;s&&(x=$i,g=vi);let h=1/0,y=null,m=null;return Jt.copy(e).invert(),Nt.matrix.copy(Jt),n.shapecast({boundsTraverseOrder:A=>we.distanceToBox(A),intersectsBounds:(A,T,b)=>b<h&&b<c?(T&&(Nt.min.copy(A.min),Nt.max.copy(A.max),Nt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(t.boundsTree){const b=t.boundsTree;return b.shapecast({boundsTraverseOrder:S=>Nt.distanceToBox(S),intersectsBounds:(S,E,M)=>M<h&&M<c,intersectsRange:(S,E)=>{for(let M=S,P=S+E;M<P;M++){const _=b.resolveTriangleIndex(M);D(d,3*_,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let I=A,C=A+T;I<C;I++){const z=n.resolveTriangleIndex(I);D(u,3*z,f,r),u.needsUpdate=!0;const L=u.distanceToTriangle(d,w,x);if(L<h&&(B.copy(w),g&&g.copy(x),h=L,y=I,m=M),L<o)return!0}}}})}else{const b=Mt(t);for(let S=0,E=b;S<E;S++){D(d,3*S,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let M=A,P=A+T;M<P;M++){const _=n.resolveTriangleIndex(M);D(u,3*_,f,r),u.needsUpdate=!0;const I=u.distanceToTriangle(d,w,x);if(I<h&&(B.copy(w),g&&g.copy(x),h=I,y=M,m=S),I<o)return!0}}}}}),W.releasePrimitive(u),W.releasePrimitive(d),h===1/0?null:(i.point?i.point.copy(B):i.point=B.clone(),i.distance=h,i.faceIndex=y,s&&(s.point?s.point.copy(g):s.point=g.clone(),s.point.applyMatrix4(Jt),B.applyMatrix4(Jt),s.distance=B.sub(s.point).length(),s.faceIndex=m),i)}function Xi(){return typeof SharedArrayBuffer<"u"}const kt=new U.constructor,le=new U.constructor,it=new Oe(()=>new J),Tt=new J,St=new J,be=new J,Be=new J;let Te=!1;function Gi(n,t,e,i){if(Te)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Te=!0;const s=n._roots,o=t._roots;let c,a=0,r=0;const f=new K().copy(e).invert();for(let l=0,p=s.length;l<p;l++){kt.setBuffer(s[l]),r=0;const u=it.getPrimitive();N(0,kt.float32Array,u),u.applyMatrix4(f);for(let d=0,w=o.length;d<w&&(le.setBuffer(o[d]),c=q(0,0,e,f,i,a,r,0,0,u),le.clearBuffer(),r+=o[d].length,!c);d++);if(it.releasePrimitive(u),kt.clearBuffer(),a+=s[l].length,c)break}return Te=!1,c}function q(n,t,e,i,s,o=0,c=0,a=0,r=0,f=null,l=!1){let p,u;l?(p=le,u=kt):(p=kt,u=le);const d=p.float32Array,w=p.uint32Array,B=p.uint16Array,x=u.float32Array,g=u.uint32Array,h=u.uint16Array,y=n*2,m=t*2,A=$(y,B),T=$(m,h);let b=!1;if(T&&A)l?b=s(v(t,g),G(t*2,h),v(n,w),G(n*2,B),r,c+t,a,o+n):b=s(v(n,w),G(n*2,B),v(t,g),G(t*2,h),a,o+n,r,c+t);else if(T){const S=it.getPrimitive();N(t,x,S),S.applyMatrix4(e);const E=O(n),M=j(n,w);N(E,d,Tt),N(M,d,St);const P=S.intersectsBox(Tt),_=S.intersectsBox(St);b=P&&q(t,E,i,e,s,c,o,r,a+1,S,!l)||_&&q(t,M,i,e,s,c,o,r,a+1,S,!l),it.releasePrimitive(S)}else{const S=O(t),E=j(t,g);N(S,x,be),N(E,x,Be);const M=f.intersectsBox(be),P=f.intersectsBox(Be);if(M&&P)b=q(n,S,e,i,s,o,c,a,r+1,f,l)||q(n,E,e,i,s,o,c,a,r+1,f,l);else if(M)if(A)b=q(n,S,e,i,s,o,c,a,r+1,f,l);else{const _=it.getPrimitive();_.copy(be).applyMatrix4(e);const I=O(n),C=j(n,w);N(I,d,Tt),N(C,d,St);const z=_.intersectsBox(Tt),L=_.intersectsBox(St);b=z&&q(S,I,i,e,s,c,o,r,a+1,_,!l)||L&&q(S,C,i,e,s,c,o,r,a+1,_,!l),it.releasePrimitive(_)}else if(P)if(A)b=q(n,E,e,i,s,o,c,a,r+1,f,l);else{const _=it.getPrimitive();_.copy(Be).applyMatrix4(e);const I=O(n),C=j(n,w);N(I,d,Tt),N(C,d,St);const z=_.intersectsBox(Tt),L=_.intersectsBox(St);b=z&&q(E,I,i,e,s,c,o,r,a+1,_,!l)||L&&q(E,C,i,e,s,c,o,r,a+1,_,!l),it.releasePrimitive(_)}}return b}const Qt=new V,cn=new J,Oi={strategy:In,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class je{static serialize(t,e={}){e={cloneBuffers:!0,...e};const i=t.geometry,s=t._roots,o=t._indirectBuffer,c=i.getIndex();let a;return e.cloneBuffers?a={roots:s.map(r=>r.slice()),index:c?c.array.slice():null,indirectBuffer:o?o.slice():null}:a={roots:s,index:c?c.array:null,indirectBuffer:o},a}static deserialize(t,e,i={}){i={setIndex:!0,indirect:!!t.indirectBuffer,...i};const{index:s,roots:o,indirectBuffer:c}=t,a=new je(e,{...i,[ge]:!0});if(a._roots=o,a._indirectBuffer=c||null,i.setIndex){const r=e.getIndex();if(r===null){const f=new fe(t.index,1,!1);e.setIndex(f)}else r.array!==s&&(r.array.set(s),r.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...Oi,[ge]:!1},e),e.useSharedArrayBuffer&&!Xi())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[ge]||(li(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new J))),this.resolveTriangleIndex=e.indirect?i=>this._indirectBuffer[i]:i=>i}refit(t=null){return(this.indirect?Li:wi)(this,t)}traverse(t,e=0){const i=this._roots[e],s=new Uint32Array(i),o=new Uint16Array(i);c(0);function c(a,r=0){const f=a*2,l=o[f+15]===pe;if(l){const p=s[a+6],u=o[f+14];t(r,l,new Float32Array(i,a*4,6),p,u)}else{const p=a+Ft/4,u=s[a+6],d=s[a+7];t(r,l,new Float32Array(i,a*4,6),d)||(c(p,r+1),c(u,r+1))}}}raycast(t,e=Ye,i=0,s=1/0){const o=this._roots,c=this.geometry,a=[],r=e.isMaterial,f=Array.isArray(e),l=c.groups,p=r?e.side:e,u=this.indirect?Ui:Si;for(let d=0,w=o.length;d<w;d++){const B=f?e[l[d].materialIndex].side:p,x=a.length;if(u(this,d,B,t,a,i,s),f){const g=l[d].materialIndex;for(let h=x,y=a.length;h<y;h++)a[h].face.materialIndex=g}}return a}raycastFirst(t,e=Ye,i=0,s=1/0){const o=this._roots,c=this.geometry,a=e.isMaterial,r=Array.isArray(e);let f=null;const l=c.groups,p=a?e.side:e,u=this.indirect?Di:Ei;for(let d=0,w=o.length;d<w;d++){const B=r?e[l[d].materialIndex].side:p,x=u(this,d,B,t,i,s);x!=null&&(f==null||x.distance<f.distance)&&(f=x,r&&(x.face.materialIndex=l[d].materialIndex))}return f}intersectsGeometry(t,e){let i=!1;const s=this._roots,o=this.indirect?Fi:Ii;for(let c=0,a=s.length;c<a&&(i=o(this,c,t,e),!i);c++);return i}shapecast(t){const e=W.getPrimitive(),i=this.indirect?Ti:xi;let{boundsTraverseOrder:s,intersectsBounds:o,intersectsRange:c,intersectsTriangle:a}=t;if(c&&a){const p=c;c=(u,d,w,B,x)=>p(u,d,w,B,x)?!0:i(u,d,this,a,w,B,e)}else c||(a?c=(p,u,d,w)=>i(p,u,this,a,d,w,e):c=(p,u,d)=>d);let r=!1,f=0;const l=this._roots;for(let p=0,u=l.length;p<u;p++){const d=l[p];if(r=pi(this,p,o,c,s,f),r)break;f+=d.byteLength}return W.releasePrimitive(e),r}bvhcast(t,e,i){let{intersectsRanges:s,intersectsTriangles:o}=i;const c=W.getPrimitive(),a=this.geometry.index,r=this.geometry.attributes.position,f=this.indirect?w=>{const B=this.resolveTriangleIndex(w);D(c,B*3,a,r)}:w=>{D(c,w*3,a,r)},l=W.getPrimitive(),p=t.geometry.index,u=t.geometry.attributes.position,d=t.indirect?w=>{const B=t.resolveTriangleIndex(w);D(l,B*3,p,u)}:w=>{D(l,w*3,p,u)};if(o){const w=(B,x,g,h,y,m,A,T)=>{for(let b=g,S=g+h;b<S;b++){d(b),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let E=B,M=B+x;E<M;E++)if(f(E),c.needsUpdate=!0,o(c,l,E,b,y,m,A,T))return!0}return!1};if(s){const B=s;s=function(x,g,h,y,m,A,T,b){return B(x,g,h,y,m,A,T,b)?!0:w(x,g,h,y,m,A,T,b)}}else s=w}return Gi(this,t,e,s)}intersectsBox(t,e){return Qt.set(t.min,t.max,e),Qt.needsUpdate=!0,this.shapecast({intersectsBounds:i=>Qt.intersectsBox(i),intersectsTriangle:i=>Qt.intersectsTriangle(i)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,i={},s={},o=0,c=1/0){return(this.indirect?Hi:Ri)(this,t,e,i,s,o,c)}closestPointToPoint(t,e={},i=0,s=1/0){return di(this,t,e,i,s)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(i=>{N(0,new Float32Array(i),cn),t.union(cn)}),t}}const Ln=1e-6,ji=Ln*.5,Un=Math.pow(10,-Math.log10(Ln)),Wi=ji*Un;function Z(n){return~~(n*Un+Wi)}function qi(n){return`${Z(n.x)},${Z(n.y)}`}function an(n){return`${Z(n.x)},${Z(n.y)},${Z(n.z)}`}function Yi(n){return`${Z(n.x)},${Z(n.y)},${Z(n.z)},${Z(n.w)}`}function Zi(n,t,e){e.direction.subVectors(t,n).normalize();const i=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-i),e}function Nn(){return typeof SharedArrayBuffer<"u"}function Ki(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,i=new SharedArrayBuffer(e.byteLength),s=new Uint8Array(e);return new Uint8Array(i).set(s,0),new t(i)}function Ji(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Qi(n,t){if(!n.index){const e=n.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ji(e,i);n.setIndex(new fe(s,1));for(let o=0;o<e;o++)s[o]=o}}function ts(n){return n.index?n.index.count:n.attributes.position.count}function We(n){return ts(n)/3}const es=1e-8,ns=new R;function is(n){return~~(n/3)}function ss(n){return n%3}function ln(n,t){return n.start-t.start}function un(n,t){return ns.subVectors(t,n.origin).dot(n.direction)}function rs(n,t,e,i=es){n.sort(ln),t.sort(ln);for(let a=0;a<n.length;a++){const r=n[a];for(let f=0;f<t.length;f++){const l=t[f];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)o(l.end,r.end)||n.splice(a+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)o(r.end,l.end)||t.splice(f+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const p=r.end;r.end=l.start,l.start=p}else if(r.start>=l.start&&r.end>=l.end){const p=l.end;l.end=r.start,r.start=p}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),c(l)&&(t.splice(f,1),f--),c(r)){n.splice(a,1),a--;break}}}s(n),s(t);function s(a){for(let r=0;r<a.length;r++)c(a[r])&&(a.splice(r,1),r--)}function o(a,r){return Math.abs(r-a)<i}function c(a){return Math.abs(a.end-a.start)<i}}const fn=1e-5,pn=1e-4;class os{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,i=t.clone();i.direction.multiplyScalar(-1);let s=1/0,o=null;for(let r=0,f=e.length;r<f;r++){const l=e[r];if(c(l,t)&&c(l,i))continue;const p=a(l,t),u=a(l,i),d=Math.min(p,u);d<s&&(s=d,o=l)}return o;function c(r,f){const l=r.origin.distanceTo(f.origin)>fn;return r.direction.angleTo(f.direction)>pn||l}function a(r,f){const l=r.origin.distanceTo(f.origin),p=r.direction.angleTo(f.direction);return l/fn+p/pn}}}const Se=new R,_e=new R,te=new En;function cs(n,t,e){const i=n.attributes,s=n.index,o=i.position,c=new Map,a=new Map,r=Array.from(t),f=new os;for(let l=0,p=r.length;l<p;l++){const u=r[l],d=is(u),w=ss(u);let B=3*d+w,x=3*d+(w+1)%3;s&&(B=s.getX(B),x=s.getX(x)),Se.fromBufferAttribute(o,B),_e.fromBufferAttribute(o,x),Zi(Se,_e,te);let g,h=f.findClosestRay(te);h===null&&(h=te.clone(),f.addRay(h)),a.has(h)||a.set(h,{forward:[],reverse:[],ray:h}),g=a.get(h);let y=un(h,Se),m=un(h,_e);y>m&&([y,m]=[m,y]),te.direction.dot(h.direction)<0?g.reverse.push({start:y,end:m,index:u}):g.forward.push({start:y,end:m,index:u})}return a.forEach(({forward:l,reverse:p},u)=>{rs(l,p,c,e),l.length===0&&p.length===0&&a.delete(u)}),{disjointConnectivityMap:c,fragmentMap:a}}const as=new Et,Ee=new R,ls=new yt,Ie=["","",""];class us{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const i=this.data[t*3+e];return i===-1?-1:~~(i/3)}getSiblingEdgeIndex(t,e){const i=this.data[t*3+e];return i===-1?-1:i%3}getDisjointSiblingTriangleIndices(t,e){const i=t*3+e,s=this.disjointConnections.get(i);return s?s.map(o=>~~(o/3)):[]}getDisjointSiblingEdgeIndices(t,e){const i=t*3+e,s=this.disjointConnections.get(i);return s?s.map(o=>o%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:i,matchDisjointEdges:s,degenerateEpsilon:o}=this,c=e?y:h,a=new Map,{attributes:r}=t,f=e?Object.keys(r):null,l=t.index,p=r.position;let u=We(t);const d=u;let w=0;i&&(w=t.drawRange.start,t.drawRange.count!==1/0&&(u=~~(t.drawRange.count/3)));let B=this.data;(!B||B.length<3*d)&&(B=new Int32Array(3*d)),B.fill(-1);let x=0,g=new Set;for(let m=w,A=u*3+w;m<A;m+=3){const T=m;for(let b=0;b<3;b++){let S=T+b;l&&(S=l.getX(S)),Ie[b]=c(S)}for(let b=0;b<3;b++){const S=(b+1)%3,E=Ie[b],M=Ie[S],P=`${M}_${E}`;if(a.has(P)){const _=T+b,I=a.get(P);B[_]=I,B[I]=_,a.delete(P),x+=2,g.delete(I)}else{const _=`${E}_${M}`,I=T+b;a.set(_,I),g.add(I)}}}if(s){const{fragmentMap:m,disjointConnectivityMap:A}=cs(t,g,o);g.clear(),m.forEach(({forward:T,reverse:b})=>{T.forEach(({index:S})=>g.add(S)),b.forEach(({index:S})=>g.add(S))}),this.unmatchedDisjointEdges=m,this.disjointConnections=A,x=u*3-g.size}this.matchedEdges=x,this.unmatchedEdges=g.size,this.data=B;function h(m){return Ee.fromBufferAttribute(p,m),an(Ee)}function y(m){let A="";for(let T=0,b=f.length;T<b;T++){const S=r[f[T]];let E;switch(S.itemSize){case 1:E=Z(S.getX(m));break;case 2:E=qi(as.fromBufferAttribute(S,m));break;case 3:E=an(Ee.fromBufferAttribute(S,m));break;case 4:E=Yi(ls.fromBufferAttribute(S,m));break}A!==""&&(A+="|"),A+=E}return A}}}class dn extends Xn{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new K,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,i=t.elements,s=e.elements;for(let o=0;o<16;o++)if(i[o]!==s[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,i=Nn();if(i)for(const s in e){const o=e[s];if(o.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");o.array=Ki(o.array)}if(t.boundsTree||(Qi(t,{useSharedArrayBuffer:i}),t.boundsTree=new je(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:i})),t.halfEdges||(t.halfEdges=new us(t)),!t.groupIndices){const s=We(t),o=new Uint16Array(s),c=t.groups;for(let a=0,r=c.length;a<r;a++){const{start:f,count:l}=c[a];for(let p=f/3,u=(f+l)/3;p<u;p++)o[p]=a}t.groupIndices=o}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}function fs(n){return n=~~n,n+4-n%4}class hn{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,i=Nn()?SharedArrayBuffer:ArrayBuffer,s=new e(new i(fs(t*e.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:i}=this;i+t.length>e.length&&(this.expand(),e=this.array);for(let s=0,o=t.length;s<o;s++)e[i+s]=t[s];this.length+=t.length}clear(){this.length=0}}class ps{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:i}=this;let s=0;for(let o=0;o<e;o++){const c=i[o];s+=c[t].length}return s}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const i=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const s={};e.push(s);for(const o in i){const c=i[o],a=new hn(c.type);a.itemSize=c.itemSize,a.normalized=c.normalized,s[o]=a}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:i}=this;if(!i[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,i,s){const{groupAttributes:o}=this,a=o[0][t];if(a){if(a.type!==e)for(let r=0,f=o.length;r<f;r++){const l=o[r][t];l.setType(e),l.itemSize=i,l.normalized=s}}else for(let r=0,f=o.length;r<f;r++){const l=new hn(e);l.itemSize=i,l.normalized=s,o[r][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const i in e)e[i].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class gn{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:i,ids:s}=this;i[t]||(i[t]=[],s.push(t)),i[t].push(e)}}const ds=0,hs=1,gs=2,ys=3,ms=4,Dn=5,Fn=6,H=new En,yn=new K,k=new X,Q=new R,mn=new yt,An=new yt,xn=new yt,Me=new yt,ee=new yt,ne=new yt,wn=new Le,Pe=new R,Ce=1e-8,As=1e-15,dt=-1,ht=1,oe=-2,ce=2,Vt=0,ft=1,qe=2,xs=1e-14;let ae=null;function bn(n){ae=n}function kn(n,t){n.getMidpoint(H.origin),n.getNormal(H.direction);const e=t.raycastFirst(H,Ge);return!!(e&&H.direction.dot(e.face.normal)>0)?dt:ht}function ws(n,t){function e(){return Math.random()-.5}n.getNormal(Pe),H.direction.copy(Pe),n.getMidpoint(H.origin);const i=3;let s=0,o=1/0;for(let c=0;c<i;c++){H.direction.x+=e()*Ce,H.direction.y+=e()*Ce,H.direction.z+=e()*Ce,H.direction.multiplyScalar(-1);const a=t.raycastFirst(H,Ge);if(!!(a&&H.direction.dot(a.face.normal)>0)&&s++,a!==null&&(o=Math.min(o,a.distance)),o<=As)return a.face.normal.dot(Pe)>0?ce:oe;if(s/i>.5||(c-s+1)/i>.5)break}return s/i>.5?dt:ht}function bs(n,t){const e=new gn,i=new gn;return yn.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,yn,{intersectsTriangles(s,o,c,a){if(!Ue(s)&&!Ue(o)){let r=s.intersectsTriangle(o,wn,!0);if(!r){const f=s.plane,l=o.plane,p=f.normal,u=l.normal;p.dot(u)===1&&Math.abs(f.constant-l.constant)<xs&&(r=!0)}if(r){let f=n.geometry.boundsTree.resolveTriangleIndex(c),l=t.geometry.boundsTree.resolveTriangleIndex(a);e.add(f,l),i.add(l,f),ae&&(ae.addEdge(wn),ae.addIntersectingTriangles(c,s,a,o))}}return!1}}),{aIntersections:e,bIntersections:i}}function Bs(n,t,e,i,s,o,c=!1){const a=e.attributes,r=e.index,f=n*3,l=r.getX(f+0),p=r.getX(f+1),u=r.getX(f+2);for(const d in o){const w=a[d],B=o[d];if(!(d in a))throw new Error(`CSG Operations: Attribute ${d} not available on geometry.`);const x=w.itemSize;d==="position"?(k.a.fromBufferAttribute(w,l).applyMatrix4(i),k.b.fromBufferAttribute(w,p).applyMatrix4(i),k.c.fromBufferAttribute(w,u).applyMatrix4(i),ze(k.a,k.b,k.c,t,3,B,c)):d==="normal"?(k.a.fromBufferAttribute(w,l).applyNormalMatrix(s),k.b.fromBufferAttribute(w,p).applyNormalMatrix(s),k.c.fromBufferAttribute(w,u).applyNormalMatrix(s),c&&(k.a.multiplyScalar(-1),k.b.multiplyScalar(-1),k.c.multiplyScalar(-1)),ze(k.a,k.b,k.c,t,3,B,c,!0)):(mn.fromBufferAttribute(w,l),An.fromBufferAttribute(w,p),xn.fromBufferAttribute(w,u),ze(mn,An,xn,t,x,B,c))}}function Ts(n,t,e,i,s,o,c,a=!1){Re(n,i,s,o,c,a),Re(a?e:t,i,s,o,c,a),Re(a?t:e,i,s,o,c,a)}function Vn(n,t,e=!1){switch(n){case ds:if(t===ht||t===ce&&!e)return ft;break;case hs:if(e){if(t===dt)return Vt}else if(t===ht||t===oe)return ft;break;case gs:if(e){if(t===ht||t===oe)return ft}else if(t===dt)return Vt;break;case ms:if(t===dt)return Vt;if(t===ht)return ft;break;case ys:if(t===dt||t===ce&&!e)return ft;break;case Dn:if(!e&&(t===ht||t===oe))return ft;break;case Fn:if(!e&&(t===dt||t===ce))return ft;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return qe}function ze(n,t,e,i,s,o,c=!1,a=!1){const r=f=>{o.push(f.x),s>1&&o.push(f.y),s>2&&o.push(f.z),s>3&&o.push(f.w)};Me.set(0,0,0,0).addScaledVector(n,i.a.x).addScaledVector(t,i.a.y).addScaledVector(e,i.a.z),ee.set(0,0,0,0).addScaledVector(n,i.b.x).addScaledVector(t,i.b.y).addScaledVector(e,i.b.z),ne.set(0,0,0,0).addScaledVector(n,i.c.x).addScaledVector(t,i.c.y).addScaledVector(e,i.c.z),a&&(Me.normalize(),ee.normalize(),ne.normalize()),r(Me),c?(r(ne),r(ee)):(r(ee),r(ne))}function Re(n,t,e,i,s,o=!1){for(const c in s){const a=t[c],r=s[c];if(!(c in t))throw new Error(`CSG Operations: Attribute ${c} no available on geometry.`);const f=a.itemSize;c==="position"?(Q.fromBufferAttribute(a,n).applyMatrix4(e),r.push(Q.x,Q.y,Q.z)):c==="normal"?(Q.fromBufferAttribute(a,n).applyNormalMatrix(i),o&&Q.multiplyScalar(-1),r.push(Q.x,Q.y,Q.z)):(r.push(a.getX(n)),f>1&&r.push(a.getY(n)),f>2&&r.push(a.getZ(n)),f>3&&r.push(a.getW(n)))}}class Ss{constructor(t){this.triangle=new X().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new X().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const i in e)t.push(e[i]);return t}}class Bn{constructor(){this.data={}}addTriangleIntersection(t,e,i,s){const{data:o}=this;o[t]||(o[t]=new Ss(e)),o[t].addTriangle(i,s)}getTrianglesAsArray(t=null){const{data:e}=this,i=[];if(t!==null)t in e&&i.push(e[t].triangle);else for(const s in e)i.push(e[s].triangle);return i}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(i=>parseInt(i)):[]}getIntersectionsAsArray(t=null,e=null){const{data:i}=this,s=new Set,o=[],c=a=>{if(i[a])if(e!==null)i[a].intersects[e]&&o.push(i[a].intersects[e]);else{const r=i[a].intersects;for(const f in r)s.has(f)||(s.add(f),o.push(r[f]))}};if(t!==null)c(t);else for(const a in i)c(a);return o}reset(){this.data={}}}class _s{constructor(){this.enabled=!1,this.triangleIntersectsA=new Bn,this.triangleIntersectsB=new Bn,this.intersectionEdges=[]}addIntersectingTriangles(t,e,i,s){const{triangleIntersectsA:o,triangleIntersectsB:c}=this;o.addTriangleIntersection(t,e,i,s),c.addTriangleIntersection(i,s,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),bn(this))}complete(){this.enabled&&bn(null)}}const rt=new K,ue=new Gn,pt=new X,ie=new X,nt=new X,se=new X,Y=[],gt=[];function Es(n){for(const t of n)return t}function Is(n,t,e,i,s,o={}){const{useGroups:c=!0}=o,{aIntersections:a,bIntersections:r}=bs(n,t),f=[];let l=null,p;return p=c?0:-1,Tn(n,t,a,e,!1,i,s,p),Sn(n,t,a,e,!1,s,p),e.findIndex(d=>d!==Fn&&d!==Dn)!==-1&&(p=c?n.geometry.groups.length||1:-1,Tn(t,n,r,e,!0,i,s,p),Sn(t,n,r,e,!0,s,p)),Y.length=0,gt.length=0,{groups:f,materials:l}}function Tn(n,t,e,i,s,o,c,a=0){const r=n.matrixWorld.determinant()<0;rt.copy(t.matrixWorld).invert().multiply(n.matrixWorld),ue.getNormalMatrix(n.matrixWorld).multiplyScalar(r?-1:1);const f=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes.position,u=t.geometry.boundsTree,d=t.geometry.index,w=t.geometry.attributes.position,B=e.ids,x=e.intersectionSet;for(let g=0,h=B.length;g<h;g++){const y=B[g],m=a===-1?0:f[y]+a,A=3*y,T=l.getX(A+0),b=l.getX(A+1),S=l.getX(A+2);pt.a.fromBufferAttribute(p,T).applyMatrix4(rt),pt.b.fromBufferAttribute(p,b).applyMatrix4(rt),pt.c.fromBufferAttribute(p,S).applyMatrix4(rt),o.reset(),o.initialize(pt);const E=x[y];for(let P=0,_=E.length;P<_;P++){const I=3*E[P],C=d.getX(I+0),z=d.getX(I+1),L=d.getX(I+2);ie.a.fromBufferAttribute(w,C),ie.b.fromBufferAttribute(w,z),ie.c.fromBufferAttribute(w,L),o.splitByTriangle(ie)}const M=o.triangles;for(let P=0,_=M.length;P<_;P++){const I=M[P],C=o.coplanarTriangleUsed?ws(I,u):kn(I,u);Y.length=0,gt.length=0;for(let z=0,L=i.length;z<L;z++){const F=Vn(i[z],C,s);F!==qe&&(gt.push(F),Y.push(c[z].getGroupAttrSet(m)))}if(Y.length!==0){pt.getBarycoord(I.a,se.a),pt.getBarycoord(I.b,se.b),pt.getBarycoord(I.c,se.c);for(let z=0,L=Y.length;z<L;z++){const F=Y[z],ct=gt[z]===Vt;Bs(y,se,n.geometry,n.matrixWorld,ue,F,r!==ct)}}}}return B.length}function Sn(n,t,e,i,s,o,c=0){const a=n.matrixWorld.determinant()<0;rt.copy(t.matrixWorld).invert().multiply(n.matrixWorld),ue.getNormalMatrix(n.matrixWorld).multiplyScalar(a?-1:1);const r=t.geometry.boundsTree,f=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes,u=p.position,d=[],w=n.geometry.halfEdges,B=new Set,x=We(n.geometry);for(let g=0,h=x;g<h;g++)g in e.intersectionSet||B.add(g);for(;B.size>0;){const g=Es(B);B.delete(g),d.push(g);const h=3*g,y=l.getX(h+0),m=l.getX(h+1),A=l.getX(h+2);nt.a.fromBufferAttribute(u,y).applyMatrix4(rt),nt.b.fromBufferAttribute(u,m).applyMatrix4(rt),nt.c.fromBufferAttribute(u,A).applyMatrix4(rt);const T=kn(nt,r);gt.length=0,Y.length=0;for(let b=0,S=i.length;b<S;b++){const E=Vn(i[b],T,s);E!==qe&&(gt.push(E),Y.push(o[b]))}for(;d.length>0;){const b=d.pop();for(let S=0;S<3;S++){const E=w.getSiblingTriangleIndex(b,S);E!==-1&&B.has(E)&&(d.push(E),B.delete(E))}if(Y.length!==0){const S=3*b,E=l.getX(S+0),M=l.getX(S+1),P=l.getX(S+2),_=c===-1?0:f[b]+c;if(nt.a.fromBufferAttribute(u,E),nt.b.fromBufferAttribute(u,M),nt.c.fromBufferAttribute(u,P),!Ue(nt))for(let I=0,C=Y.length;I<C;I++){const z=gt[I],L=Y[I].getGroupAttrSet(_),F=z===Vt;Ts(E,M,P,p,n.matrixWorld,ue,L,F!==a)}}}}}function Ms(n){for(let t=0;t<n.length-1;t++){const e=n[t],i=n[t+1];if(e.materialIndex===i.materialIndex){const s=e.start,o=i.start+i.count;i.start=s,i.count=o-s,n.splice(t,1),t--}}}function Ps(n,t,e,i){e.clear();const s=n.attributes;for(let o=0,c=i.length;o<c;o++){const a=i[o],r=s[a];e.initializeArray(a,r.array.constructor,r.itemSize,r.normalized)}for(const o in e.attributes)i.includes(o)||e.delete(o);for(const o in t.attributes)i.includes(o)||(t.deleteAttribute(o),t.dispose())}function Cs(n,t,e){let i=!1,s=-1;const o=n.attributes,c=t.groupAttributes[0];for(const r in c){const f=t.getTotalLength(r),l=t.getType(r),p=t.getItemSize(r),u=t.getNormalized(r);let d=o[r];(!d||d.array.length<f)&&(d=new fe(new l(f),p,u),n.setAttribute(r,d),i=!0);let w=0;for(let B=0,x=Math.min(e.length,t.groupCount);B<x;B++){const g=e[B].index,{array:h,type:y,length:m}=t.groupAttributes[g][r],A=new y(h.buffer,0,m);d.array.set(A,w),w+=A.length}d.needsUpdate=!0,s=f/d.itemSize}if(n.index){const r=n.index.array;if(r.length<s)n.index=null,i=!0;else for(let f=0,l=r.length;f<l;f++)r[f]=f}let a=0;n.clearGroups();for(let r=0,f=Math.min(e.length,t.groupCount);r<f;r++){const{index:l,materialIndex:p}=e[r],u=t.getCount(l);u!==0&&(n.addGroup(a,u,p),a+=u)}n.setDrawRange(0,s),n.boundsTree=null,i&&n.dispose()}function _n(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(i=>{e[i.materialIndex]=t})),e}class Rs{constructor(){this.triangleSplitter=new On,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new _s}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,i,s=new dn){let o=!0;if(Array.isArray(i)||(i=[i]),Array.isArray(s)||(s=[s],o=!1),s.length!==i.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:c,attributeData:a,attributes:r,useGroups:f,consolidateGroups:l,debug:p}=this;for(;a.length<s.length;)a.push(new ps);s.forEach((g,h)=>{Ps(t.geometry,g.geometry,a[h],r)}),p.init(),Is(t,e,i,c,a,{useGroups:f}),p.complete();const u=this.getGroupRanges(t.geometry),d=_n(u,t.material),w=this.getGroupRanges(e.geometry),B=_n(w,e.material);w.forEach(g=>g.materialIndex+=d.length);let x=[...u,...w].map((g,h)=>({...g,index:h}));if(f){const g=[...d,...B];l&&(x=x.map(y=>{const m=g[y.materialIndex];return y.materialIndex=g.indexOf(m),y}).sort((y,m)=>y.materialIndex-m.materialIndex));const h=[];for(let y=0,m=g.length;y<m;y++){let A=!1;for(let T=0,b=x.length;T<b;T++){const S=x[T];S.materialIndex===y&&(A=!0,S.materialIndex=h.length)}A&&h.push(g[y])}s.forEach(y=>{y.material=h})}else x=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach(g=>{g.material=d[0]});return s.forEach((g,h)=>{const y=g.geometry;Cs(y,a[h],x),l&&Ms(y.groups)}),o?s:s[0]}evaluateHierarchy(t,e=new dn){t.updateMatrixWorld(!0);const i=(o,c)=>{const a=o.children;for(let r=0,f=a.length;r<f;r++){const l=a[r];l.isOperationGroup?i(l,c):c(l)}},s=o=>{const c=o.children;let a=!1;for(let f=0,l=c.length;f<l;f++){const p=c[f];a=s(p)||a}const r=o.isDirty();if(r&&o.markUpdated(),a&&!o.isOperationGroup){let f;return i(o,l=>{f?f=this.evaluate(f,l,l.operation):f=this.evaluate(o,l,l.operation)}),o._cachedGeometry=f.geometry,o._cachedMaterials=f.material,!0}else return a||r};return s(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}export{ds as A,dn as B,ms as D,Rs as E,Fn as H,ys as I,je as M,gs as R,hs as S,Dn as a,N as b};
