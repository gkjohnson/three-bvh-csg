import{G as V,L as _,c as H,j as W,q as j,M as F,B as L,r as T,n as b,s as z}from"./TriangleSplitter-ByAGyBL2.js";import{M as U,b as G}from"./Evaluator-Coej1Gnr.js";const w=new T,B=new W;class O extends j{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}getVertexPosition(...t){return F.prototype.getVertexPosition.call(this,...t)}constructor(t,e,i=10,s=0){super(),this.material=e,this.geometry=new L,this.name="MeshBVHRootHelper",this.depth=i,this.displayParents=!1,this.bvh=t,this.displayEdges=!0,this._group=s}raycast(){}update(){const t=this.geometry,e=this.bvh,i=this._group;if(t.dispose(),this.visible=!1,e){const s=this.depth-1,a=this.displayParents;let o=0;e.traverse((n,u)=>{if(n>=s||u)return o++,!0;a&&o++},i);let p=0;const l=new Float32Array(24*o);e.traverse((n,u,y)=>{const d=n>=s||u;if(d||a){G(0,y,w);const{min:g,max:m}=w;for(let f=-1;f<=1;f+=2){const v=f<0?g.x:m.x;for(let x=-1;x<=1;x+=2){const I=x<0?g.y:m.y;for(let M=-1;M<=1;M+=2){const P=M<0?g.z:m.z;l[p+0]=v,l[p+1]=I,l[p+2]=P,p+=3}}}return d}},i);let h,r;this.displayEdges?r=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):r=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),l.length>65535?h=new Uint32Array(r.length*o):h=new Uint16Array(r.length*o);const c=r.length;for(let n=0;n<o;n++){const u=n*8,y=n*c;for(let d=0;d<c;d++)h[y+d]=u+r[d]}t.setIndex(new b(h,1,!1)),t.setAttribute("position",new b(l,3,!1)),this.visible=!0}}}class E extends V{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t=null,e=null,i=10){t instanceof U&&(i=e||10,e=t,t=null),typeof e=="number"&&(i=e,e=null),super(),this.name="MeshBVHHelper",this.depth=i,this.mesh=t,this.bvh=e,this.displayParents=!1,this.displayEdges=!0,this.objectIndex=0,this._roots=[];const s=new _({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),a=new H({color:65416,transparent:!0,opacity:.3,depthWrite:!1});a.color=s.color,this.edgeMaterial=s,this.meshMaterial=a,this.update()}update(){const t=this.mesh;let e=this.bvh||t.geometry.boundsTree||null;if(t.isBatchedMesh&&t.boundsTrees&&!e){const s=t._drawInfo[this.objectIndex];s&&(e=t.boundsTrees[s.geometryIndex]||e)}const i=e?e._roots.length:0;for(;this._roots.length>i;){const s=this._roots.pop();s.geometry.dispose(),this.remove(s)}for(let s=0;s<i;s++){const{depth:a,edgeMaterial:o,meshMaterial:p,displayParents:l,displayEdges:h}=this;if(s>=this._roots.length){const c=new O(e,o,a,s);this.add(c),this._roots.push(c)}const r=this._roots[s];r.bvh=e,r.depth=a,r.displayParents=l,r.displayEdges=h,r.material=h?o:p,r.update()}}updateMatrixWorld(...t){const e=this.mesh,i=this.parent;e!==null&&(e.updateWorldMatrix(!0,!1),i?this.matrix.copy(i.matrixWorld).invert().multiply(e.matrixWorld):this.matrix.copy(e.matrixWorld),(e.isInstancedMesh||e.isBatchedMesh)&&(e.getMatrixAt(this.objectIndex,B),this.matrix.multiply(B)),this.matrix.decompose(this.position,this.quaternion,this.scale)),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh,this.bvh=t.bvh,this.opacity=t.opacity,this.color.copy(t.color)}clone(){return new E(this.mesh,this.bvh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].geometry.dispose()}}class C extends z{get color(){return this.material.color}constructor(t=[]){super(),this.frustumCulled=!1,this.setEdges(t)}setEdges(t){const{geometry:e}=this,i=t.flatMap(s=>[s.start,s.end]);e.dispose(),e.setFromPoints(i)}}export{C as E,E as M};
