import{W as L,S as F,D as G,A as P,P as H,O as Q,G as U,M as W,a as O,F as R,b as A,B as V,c as _,V as s,Q as c,E as B,C as z}from"./LegacyTriangleSplitter-D3liNpRX.js";import{g as j}from"./lil-gui.module.min-BH_YJbPT.js";import{S as D,H as k,a as Y,D as J,I as K,R as X,A as Z,B as p,E as $}from"./Evaluator-BUo8MRyP.js";const ee=20;function l(t,e,n){return new z(t/2,t/2,e,ee)}const a={operation:D,overlap:0,rotation:0,wireframe:!1,displayBrushes:!0,useCDTClipping:!1};let d,h,b,w,I,m=!0,S;const C=[];te();function te(){d=new L({antialias:!0}),d.setPixelRatio(window.devicePixelRatio),d.setSize(window.innerWidth,window.innerHeight),d.setClearColor(1118481,1),document.body.appendChild(d.domElement),b=new F;const e=new G(16777215,3.5);e.position.set(-1,2,3),b.add(e,e.target),b.add(new P(11583173,.35)),h=new H(75,window.innerWidth/window.innerHeight,.1,100),h.position.set(0,5,14),h.updateProjectionMatrix(),I=new Q(h,d.domElement),I.target.set(0,0,0),I.update(),S=new $,S.attributes=["position","normal"],S.useGroups=!0;const n=4,o=ne(),r=(o.length-1)*n;for(let i=0;i<o.length;i++){const u=o[i],q=i*n-r/2,g=new U;g.position.x=q,b.add(g);const y=new W({color:16777215,opacity:.15,transparent:!0,depthWrite:!1,side:O,premultipliedAlpha:!0}),x=new W({color:15277667,opacity:.15,transparent:!0,depthWrite:!1,side:O,premultipliedAlpha:!0,roughness:.25});u.brush1.material=y,u.brush2.material=x,g.add(u.brush1,u.brush2);const f=y.clone();f.side=R,f.opacity=1,f.transparent=!1,f.depthWrite=!0;const E=x.clone();E.side=R,E.opacity=1,E.transparent=!1,E.depthWrite=!0;const M=new Map;M.set(y,f),M.set(x,E);const T=new A(new V,new W);b.add(T);const v=new A(T.geometry,new _({wireframe:!0,color:0,opacity:.35,transparent:!0}));g.add(v),C.push({label:u.label,brush1:u.brush1,brush2:u.brush2,posStart:u.posStart,posEnd:u.posEnd,rotStart:u.rotStart,rotEnd:u.rotEnd,result:T,wireframe:v,materialMap:M})}w=new j,w.add(a,"operation",{ADDITION:Z,SUBTRACTION:D,REVERSE_SUBTRACTION:X,INTERSECTION:K,DIFFERENCE:J,HOLLOW_INTERSECTION:Y,HOLLOW_SUBTRACTION:k}).onChange(()=>{m=!0}),w.add(a,"overlap",0,1,.01).onChange(()=>{m=!0}),w.add(a,"rotation",0,1,.01).onChange(()=>{m=!0}),w.add(a,"wireframe"),w.add(a,"displayBrushes"),w.add(a,"useCDTClipping").onChange(()=>{m=!0}),window.addEventListener("resize",function(){h.aspect=window.innerWidth/window.innerHeight,h.updateProjectionMatrix(),d.setSize(window.innerWidth,window.innerHeight)},!1),N()}function ne(){const t=[];{const e=new s(0,2,0),n=new c,o=new p(l(2,2)),r=new p(l(2,2));r.position.copy(e),t.push({label:"axis-aligned",brush1:o,brush2:r,posStart:e,posEnd:new s(0,0,0),rotStart:n,rotEnd:n.clone()})}{const e=new c().setFromEuler(new B(.7,.4,.3)),n=new s(0,2,0).applyQuaternion(e),o=e.clone(),r=new p(l(2,2)),i=new p(l(2,2));r.quaternion.copy(e),i.quaternion.copy(e),i.position.copy(n),t.push({label:"rotated",brush1:r,brush2:i,posStart:n,posEnd:new s(0,0,0),rotStart:o,rotEnd:o.clone()})}{const e=new s(0,1.5,0),n=new c,o=new p(l(2,2)),r=new p(l(1,1));r.position.copy(e),t.push({label:"partial overlap",brush1:o,brush2:r,posStart:e,posEnd:new s(0,0,0),rotStart:n,rotEnd:n.clone()})}{const e=new s(0,2.0000001,0),n=new c,o=new p(l(2,2)),r=new p(l(2,2));r.position.copy(e),t.push({label:"epsilon offset",brush1:o,brush2:r,posStart:e,posEnd:new s(0,1e-7,0),rotStart:n,rotEnd:n.clone()})}{const e=new s(0,2,0),n=new c().setFromEuler(new B(0,Math.PI/4,0)),o=new c().setFromAxisAngle(new s(0,1,0),3*Math.PI/4),r=new p(l(2,2)),i=new p(l(2,2));i.quaternion.copy(n),i.position.copy(e),t.push({label:"rotated 45",brush1:r,brush2:i,posStart:e,posEnd:new s(1,2,1),rotStart:n,rotEnd:o})}{const e=new s(0,1.75,0),n=new c,o=new p(l(3,3)),r=new p(l(.5,.5));r.position.copy(e),t.push({label:"scale mismatch",brush1:o,brush2:r,posStart:e,posEnd:new s(0,0,0),rotStart:n,rotEnd:n.clone()})}return t}function N(){if(requestAnimationFrame(N),m){S.useCDTClipping=a.useCDTClipping,m=!1,b.updateMatrixWorld(!0);for(let t=0;t<C.length;t++){const e=C[t];e.brush2.position.lerpVectors(e.posStart,e.posEnd,a.overlap),e.brush2.quaternion.slerpQuaternions(e.rotStart,e.rotEnd,a.rotation),e.brush1.updateMatrixWorld(!0),e.brush2.updateMatrixWorld(!0),S.evaluate(e.brush1,e.brush2,a.operation,e.result),e.result.material=e.result.material.map(n=>e.materialMap.get(n))}}for(const t of C)t.brush1.visible=a.displayBrushes,t.brush2.visible=a.displayBrushes,t.wireframe.visible=a.wireframe,t.brush1.matrix.decompose(t.wireframe.position,t.wireframe.quaternion,t.wireframe.scale);d.render(b,h)}
