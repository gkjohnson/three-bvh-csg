import{r as zt,j as It,n as te,V as U,at as Sn,au as Ht,av as ai,aw as Ut,d as pn,T as Mt,l as ci,a as Hr,ax as qr,ay as $e,F as Ye,az as Mn,b as li,aA as yn,aB as ui,aC as Ee,aD as hi,aE as Ze}from"./LegacyTriangleSplitter-D3liNpRX.js";const Xr=0,fi=1,gi=2,Ke=2,ae=1.25,Je=1,xt=32,gt=xt/4,Gr=65535,Zn=Math.pow(2,-24),Oe=Symbol("SKIP_GENERATION"),Wr={strategy:Xr,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[Oe]:!1};function ht(l,r,i){return i.min.x=r[l],i.min.y=r[l+1],i.min.z=r[l+2],i.max.x=r[l+3],i.max.y=r[l+4],i.max.z=r[l+5],i}function Qe(l){let r=-1,i=-1/0;for(let o=0;o<3;o++){const s=l[o+3]-l[o];s>i&&(i=s,r=o)}return r}function me(l,r){r.set(l)}function tr(l,r,i){let o,s;for(let h=0;h<3;h++){const f=h+3;o=l[h],s=r[h],i[h]=o<s?o:s,o=l[f],s=r[f],i[f]=o>s?o:s}}function En(l,r,i){for(let o=0;o<3;o++){const s=r[l+2*o],h=r[l+2*o+1],f=s-h,g=s+h;f<i[o]&&(i[o]=f),g>i[o+3]&&(i[o+3]=g)}}function xn(l){const r=l[3]-l[0],i=l[4]-l[1],o=l[5]-l[2];return 2*(r*i+i*o+o*r)}function pt(l,r){return r[l+15]===Gr}function wt(l,r){return r[l+6]}function bt(l,r){return r[l+14]}function yt(l){return l+gt}function vt(l,r){const i=r[l+6];return l+i*gt}function ke(l,r){return r[l+7]}function ce(l,r,i,o,s){let h=1/0,f=1/0,g=1/0,p=-1/0,y=-1/0,a=-1/0,u=1/0,c=1/0,x=1/0,d=-1/0,M=-1/0,S=-1/0;const E=l.offset||0;for(let T=(r-E)*6,e=(r+i-E)*6;T<e;T+=6){const n=l[T+0],v=l[T+1],t=n-v,P=n+v;t<h&&(h=t),P>p&&(p=P),n<u&&(u=n),n>d&&(d=n);const B=l[T+2],b=l[T+3],w=B-b,_=B+b;w<f&&(f=w),_>y&&(y=_),B<c&&(c=B),B>M&&(M=B);const A=l[T+4],I=l[T+5],C=A-I,D=A+I;C<g&&(g=C),D>a&&(a=D),A<x&&(x=A),A>S&&(S=A)}o[0]=h,o[1]=f,o[2]=g,o[3]=p,o[4]=y,o[5]=a,s[0]=u,s[1]=c,s[2]=x,s[3]=d,s[4]=M,s[5]=S}const Lt=32,pi=(l,r)=>l.candidate-r.candidate,Ft=new Array(Lt).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Pn=new Float32Array(6);function yi(l,r,i,o,s,h){let f=-1,g=0;if(h===Xr)f=Qe(r),f!==-1&&(g=(r[f]+r[f+3])/2);else if(h===fi)f=Qe(l),f!==-1&&(g=vi(i,o,s,f));else if(h===gi){const p=xn(l);let y=ae*s;const a=i.offset||0,u=(o-a)*6,c=(o+s-a)*6;for(let x=0;x<3;x++){const d=r[x],E=(r[x+3]-d)/Lt;if(s<Lt/4){const T=[...Ft];T.length=s;let e=0;for(let v=u;v<c;v+=6,e++){const t=T[e];t.candidate=i[v+2*x],t.count=0;const{bounds:P,leftCacheBounds:B,rightCacheBounds:b}=t;for(let w=0;w<3;w++)b[w]=1/0,b[w+3]=-1/0,B[w]=1/0,B[w+3]=-1/0,P[w]=1/0,P[w+3]=-1/0;En(v,i,P)}T.sort(pi);let n=s;for(let v=0;v<n;v++){const t=T[v];for(;v+1<n&&T[v+1].candidate===t.candidate;)T.splice(v+1,1),n--}for(let v=u;v<c;v+=6){const t=i[v+2*x];for(let P=0;P<n;P++){const B=T[P];t>=B.candidate?En(v,i,B.rightCacheBounds):(En(v,i,B.leftCacheBounds),B.count++)}}for(let v=0;v<n;v++){const t=T[v],P=t.count,B=s-t.count,b=t.leftCacheBounds,w=t.rightCacheBounds;let _=0;P!==0&&(_=xn(b)/p);let A=0;B!==0&&(A=xn(w)/p);const I=Je+ae*(_*P+A*B);I<y&&(f=x,y=I,g=t.candidate)}}else{for(let n=0;n<Lt;n++){const v=Ft[n];v.count=0,v.candidate=d+E+n*E;const t=v.bounds;for(let P=0;P<3;P++)t[P]=1/0,t[P+3]=-1/0}for(let n=u;n<c;n+=6){let P=~~((i[n+2*x]-d)/E);P>=Lt&&(P=Lt-1);const B=Ft[P];B.count++,En(n,i,B.bounds)}const T=Ft[Lt-1];me(T.bounds,T.rightCacheBounds);for(let n=Lt-2;n>=0;n--){const v=Ft[n],t=Ft[n+1];tr(v.bounds,t.rightCacheBounds,v.rightCacheBounds)}let e=0;for(let n=0;n<Lt-1;n++){const v=Ft[n],t=v.count,P=v.bounds,b=Ft[n+1].rightCacheBounds;t!==0&&(e===0?me(P,Pn):tr(P,Pn,Pn)),e+=t;let w=0,_=0;e!==0&&(w=xn(Pn)/p);const A=s-e;A!==0&&(_=xn(b)/p);const I=Je+ae*(w*e+_*A);I<y&&(f=x,y=I,g=v.candidate)}}}}else console.warn(`BVH: Invalid build strategy value ${h} used.`);return{axis:f,pos:g}}function vi(l,r,i,o){let s=0;const h=l.offset;for(let f=r,g=r+i;f<g;f++)s+=l[(f-h)*6+o*2];return s/i}class le{constructor(){this.boundingData=new Float32Array(6)}}function xi(l,r,i,o,s,h){let f=o,g=o+s-1;const p=h.pos,y=h.axis*2,a=i.offset||0;for(;;){for(;f<=g&&i[(f-a)*6+y]<p;)f++;for(;f<=g&&i[(g-a)*6+y]>=p;)g--;if(f<g){for(let u=0;u<r;u++){let c=l[f*r+u];l[f*r+u]=l[g*r+u],l[g*r+u]=c}for(let u=0;u<6;u++){const c=f-a,x=g-a,d=i[c*6+u];i[c*6+u]=i[x*6+u],i[x*6+u]=d}f++,g--}else return f}}let jr,Kn,Pe,Yr;const wi=Math.pow(2,32);function Ce(l){return"count"in l?1:1+Ce(l.left)+Ce(l.right)}function bi(l,r,i){return jr=new Float32Array(i),Kn=new Uint32Array(i),Pe=new Uint16Array(i),Yr=new Uint8Array(i),De(l,r)}function De(l,r){const i=l/4,o=l/2,s="count"in r,h=r.boundingData;for(let f=0;f<6;f++)jr[i+f]=h[f];if(s)return r.buffer?(Yr.set(new Uint8Array(r.buffer),l),l+r.buffer.byteLength):(Kn[i+6]=r.offset,Pe[o+14]=r.count,Pe[o+15]=Gr,l+xt);{const{left:f,right:g,splitAxis:p}=r,y=l+xt;let a=De(y,f);const u=l/xt,x=a/xt-u;if(x>wi)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return Kn[i+6]=x,Kn[i+7]=p,De(a,g)}}function Ai(l,r,i,o,s,h){const{maxDepth:f,verbose:g,maxLeafSize:p,strategy:y,onProgress:a}=s,u=l.primitiveBuffer,c=l.primitiveBufferStride,x=new Float32Array(6);let d=!1;const M=new le;return ce(r,i,o,M.boundingData,x),E(M,i,o,x),M;function S(T){a&&a((T-h.offset)/h.count)}function E(T,e,n,v=null,t=0){if(!d&&t>=f&&(d=!0,g&&console.warn(`BVH: Max depth of ${f} reached when generating BVH. Consider increasing maxDepth.`)),n<=p||t>=f)return S(e+n),T.offset=e,T.count=n,T;const P=yi(T.boundingData,v,r,e,n,y);if(P.axis===-1)return S(e+n),T.offset=e,T.count=n,T;const B=xi(u,c,r,e,n,P);if(B===e||B===e+n)S(e+n),T.offset=e,T.count=n;else{T.splitAxis=P.axis;const b=new le,w=e,_=B-e;T.left=b,ce(r,w,_,b.boundingData,x),E(b,w,_,x,t+1);const A=new le,I=B,C=n-_;T.right=A,ce(r,I,C,A.boundingData,x),E(A,I,C,x,t+1)}return T}}function _i(l,r){const i=r.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=l.getRootRanges(r.range),s=o[0],h=o[o.length-1],f={offset:s.offset,count:h.offset+h.count-s.offset},g=new Float32Array(6*f.count);g.offset=f.offset,l.computePrimitiveBounds(f.offset,f.count,g),l._roots=o.map(p=>{const y=Ai(l,g,p.offset,p.count,r,f),a=Ce(y),u=new i(xt*a);return bi(0,y,u),u})}class He{constructor(r){this._getNewPrimitive=r,this._primitives=[]}getPrimitive(){const r=this._primitives;return r.length===0?this._getNewPrimitive():r.pop()}releasePrimitive(r){this._primitives.push(r)}}class Bi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const r=[];let i=null;this.setBuffer=o=>{i&&r.push(i),i=o,this.float32Array=new Float32Array(o),this.uint16Array=new Uint16Array(o),this.uint32Array=new Uint32Array(o)},this.clearBuffer=()=>{i=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,r.length!==0&&this.setBuffer(r.pop())}}}const nt=new Bi;let kt,fn;const mt=[],Cn=new He(()=>new zt);function Ti(l,r,i,o,s,h){kt=Cn.getPrimitive(),fn=Cn.getPrimitive(),mt.push(kt,fn),nt.setBuffer(l._roots[r]);const f=Ne(0,l.geometry,i,o,s,h);nt.clearBuffer(),Cn.releasePrimitive(kt),Cn.releasePrimitive(fn),mt.pop(),mt.pop();const g=mt.length;return g>0&&(fn=mt[g-1],kt=mt[g-2]),f}function Ne(l,r,i,o,s=null,h=0,f=0){const{float32Array:g,uint16Array:p,uint32Array:y}=nt;let a=l*2;if(pt(a,p)){const c=wt(l,y),x=bt(a,p);return ht(l,g,kt),o(c,x,!1,f,h+l/gt,kt)}else{let w=function(A){const{uint16Array:I,uint32Array:C}=nt;let D=A*2;for(;!pt(D,I);)A=yt(A),D=A*2;return wt(A,C)},_=function(A){const{uint16Array:I,uint32Array:C}=nt;let D=A*2;for(;!pt(D,I);)A=vt(A,C),D=A*2;return wt(A,C)+bt(D,I)};const c=yt(l),x=vt(l,y);let d=c,M=x,S,E,T,e;if(s&&(T=kt,e=fn,ht(d,g,T),ht(M,g,e),S=s(T),E=s(e),E<S)){d=x,M=c;const A=S;S=E,E=A,T=e}T||(T=kt,ht(d,g,T));const n=pt(d*2,p),v=i(T,n,S,f+1,h+d/gt);let t;if(v===Ke){const A=w(d),C=_(d)-A;t=o(A,C,!0,f+1,h+d/gt,T)}else t=v&&Ne(d,r,i,o,s,h,f+1);if(t)return!0;e=fn,ht(M,g,e);const P=pt(M*2,p),B=i(e,P,E,f+1,h+M/gt);let b;if(B===Ke){const A=w(M),C=_(M)-A;b=o(A,C,!0,f+1,h+M/gt,e)}else b=B&&Ne(M,r,i,o,s,h,f+1);return!!b}}const In=new nt.constructor,ne=new nt.constructor,$t=new He(()=>new zt),tn=new zt,nn=new zt,ue=new zt,he=new zt;let fe=!1;function Ii(l,r,i,o){if(fe)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");fe=!0;const s=l._roots,h=r._roots;let f,g=0,p=0;const y=new It().copy(i).invert();for(let a=0,u=s.length;a<u;a++){In.setBuffer(s[a]),p=0;const c=$t.getPrimitive();ht(0,In.float32Array,c),c.applyMatrix4(y);for(let x=0,d=h.length;x<d&&(ne.setBuffer(h[x]),f=Dt(0,0,i,y,o,g,p,0,0,c),ne.clearBuffer(),p+=h[x].byteLength/xt,!f);x++);if($t.releasePrimitive(c),In.clearBuffer(),g+=s[a].byteLength/xt,f)break}return fe=!1,f}function Dt(l,r,i,o,s,h=0,f=0,g=0,p=0,y=null,a=!1){let u,c;a?(u=ne,c=In):(u=In,c=ne);const x=u.float32Array,d=u.uint32Array,M=u.uint16Array,S=c.float32Array,E=c.uint32Array,T=c.uint16Array,e=l*2,n=r*2,v=pt(e,M),t=pt(n,T);let P=!1;if(t&&v)a?P=s(wt(r,E),bt(r*2,T),wt(l,d),bt(l*2,M),p,f+r/gt,g,h+l/gt):P=s(wt(l,d),bt(l*2,M),wt(r,E),bt(r*2,T),g,h+l/gt,p,f+r/gt);else if(t){const B=$t.getPrimitive();ht(r,S,B),B.applyMatrix4(i);const b=yt(l),w=vt(l,d);ht(b,x,tn),ht(w,x,nn);const _=B.intersectsBox(tn),A=B.intersectsBox(nn);P=_&&Dt(r,b,o,i,s,f,h,p,g+1,B,!a)||A&&Dt(r,w,o,i,s,f,h,p,g+1,B,!a),$t.releasePrimitive(B)}else{const B=yt(r),b=vt(r,E);ht(B,S,ue),ht(b,S,he);const w=y.intersectsBox(ue),_=y.intersectsBox(he);if(w&&_)P=Dt(l,B,i,o,s,h,f,g,p+1,y,a)||Dt(l,b,i,o,s,h,f,g,p+1,y,a);else if(w)if(v)P=Dt(l,B,i,o,s,h,f,g,p+1,y,a);else{const A=$t.getPrimitive();A.copy(ue).applyMatrix4(i);const I=yt(l),C=vt(l,d);ht(I,x,tn),ht(C,x,nn);const D=A.intersectsBox(tn),N=A.intersectsBox(nn);P=D&&Dt(B,I,o,i,s,f,h,p,g+1,A,!a)||N&&Dt(B,C,o,i,s,f,h,p,g+1,A,!a),$t.releasePrimitive(A)}else if(_)if(v)P=Dt(l,b,i,o,s,h,f,g,p+1,y,a);else{const A=$t.getPrimitive();A.copy(he).applyMatrix4(i);const I=yt(l),C=vt(l,d);ht(I,x,tn),ht(C,x,nn);const D=A.intersectsBox(tn),N=A.intersectsBox(nn);P=D&&Dt(b,I,o,i,s,f,h,p,g+1,A,!a)||N&&Dt(b,C,o,i,s,f,h,p,g+1,A,!a),$t.releasePrimitive(A)}}return P}const nr=new zt,en=new Float32Array(6);class di{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(r){r={...Wr,...r},_i(this,r)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(r,i,o,s){let h=1/0,f=1/0,g=1/0,p=-1/0,y=-1/0,a=-1/0;for(let u=r,c=r+i;u<c;u++){this.writePrimitiveBounds(u,en,0);const[x,d,M,S,E,T]=en;x<h&&(h=x),S>p&&(p=S),d<f&&(f=d),E>y&&(y=E),M<g&&(g=M),T>a&&(a=T)}return o[s+0]=h,o[s+1]=f,o[s+2]=g,o[s+3]=p,o[s+4]=y,o[s+5]=a,o}computePrimitiveBounds(r,i,o){const s=o.offset||0;for(let h=r,f=r+i;h<f;h++){this.writePrimitiveBounds(h,en,0);const[g,p,y,a,u,c]=en,x=(g+a)/2,d=(p+u)/2,M=(y+c)/2,S=(a-g)/2,E=(u-p)/2,T=(c-y)/2,e=(h-s)*6;o[e+0]=x,o[e+1]=S+(Math.abs(x)+S)*Zn,o[e+2]=d,o[e+3]=E+(Math.abs(d)+E)*Zn,o[e+4]=M,o[e+5]=T+(Math.abs(M)+T)*Zn}return o}shiftPrimitiveOffsets(r){const i=this._indirectBuffer;if(i)for(let o=0,s=i.length;o<s;o++)i[o]+=r;else{const o=this._roots;for(let s=0;s<o.length;s++){const h=o[s],f=new Uint32Array(h),g=new Uint16Array(h),p=h.byteLength/xt;for(let y=0;y<p;y++){const a=gt*y,u=2*a;pt(u,g)&&(f[a+6]+=r)}}}}traverse(r,i=0){const o=this._roots[i],s=new Uint32Array(o),h=new Uint16Array(o);f(0);function f(g,p=0){const y=g*2,a=pt(y,h);if(a){const u=s[g+6],c=h[y+14];r(p,a,new Float32Array(o,g*4,6),u,c)}else{const u=yt(g),c=vt(g,s),x=ke(g,s);r(p,a,new Float32Array(o,g*4,6),x)||(f(u,p+1),f(c,p+1))}}}refit(){const r=this._roots;for(let i=0,o=r.length;i<o;i++){const s=r[i],h=new Uint32Array(s),f=new Uint16Array(s),g=new Float32Array(s),p=s.byteLength/xt;for(let y=p-1;y>=0;y--){const a=y*gt,u=a*2;if(pt(u,f)){const x=wt(a,h),d=bt(u,f);this.writePrimitiveRangeBounds(x,d,en,0),g.set(en,a)}else{const x=yt(a),d=vt(a,h);for(let M=0;M<3;M++){const S=g[x+M],E=g[x+M+3],T=g[d+M],e=g[d+M+3];g[a+M]=S<T?S:T,g[a+M+3]=E>e?E:e}}}}}getBoundingBox(r){return r.makeEmpty(),this._roots.forEach(o=>{ht(0,new Float32Array(o),nr),r.union(nr)}),r}shapecast(r){let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:s,intersectsPrimitive:h,scratchPrimitive:f,iterate:g}=r;if(s&&h){const u=s;s=(c,x,d,M,S)=>u(c,x,d,M,S)?!0:g(c,x,this,h,d,M,f)}else s||(h?s=(u,c,x,d)=>g(u,c,this,h,x,d,f):s=(u,c,x)=>x);let p=!1,y=0;const a=this._roots;for(let u=0,c=a.length;u<c;u++){const x=a[u];if(p=Ti(this,u,o,s,i,y),p)break;y+=x.byteLength/xt}return p}bvhcast(r,i,o){let{intersectsRanges:s}=o;return Ii(this,r,i,s)}}function Si(){return typeof SharedArrayBuffer<"u"}function qe(l){return l.index?l.index.count:l.attributes.position.count}function ie(l){return qe(l)/3}function Mi(l,r=ArrayBuffer){return l>65535?new Uint32Array(new r(4*l)):new Uint16Array(new r(2*l))}function Ei(l,r){if(!l.index){const i=l.attributes.position.count,o=r.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Mi(i,o);l.setIndex(new te(s,1));for(let h=0;h<i;h++)s[h]=h}}function Pi(l,r,i){const o=qe(l)/i,s=r||l.drawRange,h=s.start/i,f=(s.start+s.count)/i,g=Math.max(0,h),p=Math.min(o,f)-g;return{offset:Math.floor(g),count:Math.floor(p)}}function Ci(l,r){return l.groups.map(i=>({offset:i.start/r,count:i.count/r}))}function er(l,r,i){const o=Pi(l,r,i),s=Ci(l,i);if(!s.length)return[o];const h=[],f=o.offset,g=o.offset+o.count,p=qe(l)/i,y=[];for(const c of s){const{offset:x,count:d}=c,M=x,S=isFinite(d)?d:p-x,E=x+S;M<g&&E>f&&(y.push({pos:Math.max(f,M),isStart:!0}),y.push({pos:Math.min(g,E),isStart:!1}))}y.sort((c,x)=>c.pos!==x.pos?c.pos-x.pos:c.type==="end"?-1:1);let a=0,u=null;for(const c of y){const x=c.pos;a!==0&&x!==u&&h.push({offset:u,count:x-u}),a+=c.isStart?1:-1,u=x}return h}function Di(l,r){const i=l[l.length-1],o=i.offset+i.count>2**16,s=l.reduce((y,a)=>y+a.count,0),h=o?4:2,f=r?new SharedArrayBuffer(s*h):new ArrayBuffer(s*h),g=o?new Uint32Array(f):new Uint16Array(f);let p=0;for(let y=0;y<l.length;y++){const{offset:a,count:u}=l[y];for(let c=0;c<u;c++)g[p+c]=a+c;p+=u}return g}class Ni extends di{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(r){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(r){}constructor(r,i={}){if(r.isBufferGeometry){if(r.index&&r.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(i.useSharedArrayBuffer&&!Si())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=r,this.resolvePrimitiveIndex=i.indirect?o=>this._indirectBuffer[o]:o=>o,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,i={...Wr,...i},i[Oe]||this.init(i)}init(r){const{geometry:i,primitiveStride:o}=this;if(r.indirect){const s=er(i,r.range,o),h=Di(s,r.useSharedArrayBuffer);this._indirectBuffer=h}else Ei(i,r);super.init(r),!i.boundingBox&&r.setBoundingBox&&(i.boundingBox=this.getBoundingBox(new zt))}getRootRanges(r){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:er(this.geometry,r,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class At{constructor(r,i,o){this.isOrientedBox=!0,this.min=new U,this.max=new U,this.matrix=new It,this.invMatrix=new It,this.points=new Array(8).fill().map(()=>new U),this.satAxes=new Array(3).fill().map(()=>new U),this.satBounds=new Array(3).fill().map(()=>new Sn),this.alignedSatBounds=new Array(3).fill().map(()=>new Sn),this.needsUpdate=!1,r&&this.min.copy(r),i&&this.max.copy(i),o&&this.matrix.copy(o)}set(r,i,o){this.min.copy(r),this.max.copy(i),this.matrix.copy(o),this.needsUpdate=!0}copy(r){this.min.copy(r.min),this.max.copy(r.max),this.matrix.copy(r.matrix),this.needsUpdate=!0}}At.prototype.update=(function(){return function(){const r=this.matrix,i=this.min,o=this.max,s=this.points;for(let y=0;y<=1;y++)for(let a=0;a<=1;a++)for(let u=0;u<=1;u++){const c=1*y|2*a|4*u,x=s[c];x.x=y?o.x:i.x,x.y=a?o.y:i.y,x.z=u?o.z:i.z,x.applyMatrix4(r)}const h=this.satBounds,f=this.satAxes,g=s[0];for(let y=0;y<3;y++){const a=f[y],u=h[y],c=1<<y,x=s[c];a.subVectors(g,x),u.setFromPoints(a,s)}const p=this.alignedSatBounds;p[0].setFromPointsField(s,"x"),p[1].setFromPointsField(s,"y"),p[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}})();At.prototype.intersectsBox=(function(){const l=new Sn;return function(i){this.needsUpdate&&this.update();const o=i.min,s=i.max,h=this.satBounds,f=this.satAxes,g=this.alignedSatBounds;if(l.min=o.x,l.max=s.x,g[0].isSeparated(l)||(l.min=o.y,l.max=s.y,g[1].isSeparated(l))||(l.min=o.z,l.max=s.z,g[2].isSeparated(l)))return!1;for(let p=0;p<3;p++){const y=f[p],a=h[p];if(l.setFromBox(y,i),a.isSeparated(l))return!1}return!0}})();At.prototype.intersectsTriangle=(function(){const l=new Ht,r=new Array(3),i=new Sn,o=new Sn,s=new U;return function(f){this.needsUpdate&&this.update(),f.isExtendedTriangle?f.needsUpdate&&f.update():(l.copy(f),l.update(),f=l);const g=this.satBounds,p=this.satAxes;r[0]=f.a,r[1]=f.b,r[2]=f.c;for(let c=0;c<3;c++){const x=g[c],d=p[c];if(i.setFromPoints(d,r),x.isSeparated(i))return!1}const y=f.satBounds,a=f.satAxes,u=this.points;for(let c=0;c<3;c++){const x=y[c],d=a[c];if(i.setFromPoints(d,u),x.isSeparated(i))return!1}for(let c=0;c<3;c++){const x=p[c];for(let d=0;d<4;d++){const M=a[d];if(s.crossVectors(x,M),i.setFromPoints(s,r),o.setFromPoints(s,u),i.isSeparated(o))return!1}}return!0}})();At.prototype.closestPointToPoint=(function(){return function(r,i){return this.needsUpdate&&this.update(),i.copy(r).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),i}})();At.prototype.distanceToPoint=(function(){const l=new U;return function(i){return this.closestPointToPoint(i,l),i.distanceTo(l)}})();At.prototype.distanceToBox=(function(){const l=["x","y","z"],r=new Array(12).fill().map(()=>new Ut),i=new Array(12).fill().map(()=>new Ut),o=new U,s=new U;return function(f,g=0,p=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(f))return(p||y)&&(f.getCenter(s),this.closestPointToPoint(s,o),f.closestPointToPoint(o,s),p&&p.copy(o),y&&y.copy(s)),0;const a=g*g,u=f.min,c=f.max,x=this.points;let d=1/0;for(let S=0;S<8;S++){const E=x[S];s.copy(E).clamp(u,c);const T=E.distanceToSquared(s);if(T<d&&(d=T,p&&p.copy(E),y&&y.copy(s),T<a))return Math.sqrt(T)}let M=0;for(let S=0;S<3;S++)for(let E=0;E<=1;E++)for(let T=0;T<=1;T++){const e=(S+1)%3,n=(S+2)%3,v=E<<e|T<<n,t=1<<S|E<<e|T<<n,P=x[v],B=x[t];r[M].set(P,B);const w=l[S],_=l[e],A=l[n],I=i[M],C=I.start,D=I.end;C[w]=u[w],C[_]=E?u[_]:c[_],C[A]=T?u[A]:c[_],D[w]=c[w],D[_]=E?u[_]:c[_],D[A]=T?u[A]:c[_],M++}for(let S=0;S<=1;S++)for(let E=0;E<=1;E++)for(let T=0;T<=1;T++){s.x=S?c.x:u.x,s.y=E?c.y:u.y,s.z=T?c.z:u.z,this.closestPointToPoint(s,o);const e=s.distanceToSquared(o);if(e<d&&(d=e,p&&p.copy(o),y&&y.copy(s),e<a))return Math.sqrt(e)}for(let S=0;S<12;S++){const E=r[S];for(let T=0;T<12;T++){const e=i[T];ai(E,e,o,s);const n=o.distanceToSquared(s);if(n<d&&(d=n,p&&p.copy(o),y&&y.copy(s),n<a))return Math.sqrt(n)}}return Math.sqrt(d)}})();class Ri extends He{constructor(){super(()=>new Ht)}}const Et=new Ri,wn=new U,ge=new U;function zi(l,r,i={},o=0,s=1/0){const h=o*o,f=s*s;let g=1/0,p=null;if(l.shapecast({boundsTraverseOrder:a=>(wn.copy(r).clamp(a.min,a.max),wn.distanceToSquared(r)),intersectsBounds:(a,u,c)=>c<g&&c<f,intersectsTriangle:(a,u)=>{a.closestPointToPoint(r,wn);const c=r.distanceToSquared(wn);return c<g&&(ge.copy(wn),g=c,p=u),c<h}}),g===1/0)return null;const y=Math.sqrt(g);return i.point?i.point.copy(ge):i.point=ge.clone(),i.distance=y,i.faceIndex=p,i}const Dn=parseInt(qr)>=169,Li=parseInt(qr)<=161,Gt=new U,Wt=new U,jt=new U,Nn=new pn,Rn=new pn,zn=new pn,rr=new U,ir=new U,or=new U,bn=new U;function Ui(l,r,i,o,s,h,f,g){let p;if(h===ci?p=l.intersectTriangle(o,i,r,!0,s):p=l.intersectTriangle(r,i,o,h!==Hr,s),p===null)return null;const y=l.origin.distanceTo(s);return y<f||y>g?null:{distance:y,point:s.clone()}}function sr(l,r,i,o,s,h,f,g,p,y,a){Gt.fromBufferAttribute(r,h),Wt.fromBufferAttribute(r,f),jt.fromBufferAttribute(r,g);const u=Ui(l,Gt,Wt,jt,bn,p,y,a);if(u){if(o){Nn.fromBufferAttribute(o,h),Rn.fromBufferAttribute(o,f),zn.fromBufferAttribute(o,g),u.uv=new pn;const x=Mt.getInterpolation(bn,Gt,Wt,jt,Nn,Rn,zn,u.uv);Dn||(u.uv=x)}if(s){Nn.fromBufferAttribute(s,h),Rn.fromBufferAttribute(s,f),zn.fromBufferAttribute(s,g),u.uv1=new pn;const x=Mt.getInterpolation(bn,Gt,Wt,jt,Nn,Rn,zn,u.uv1);Dn||(u.uv1=x),Li&&(u.uv2=u.uv1)}if(i){rr.fromBufferAttribute(i,h),ir.fromBufferAttribute(i,f),or.fromBufferAttribute(i,g),u.normal=new U;const x=Mt.getInterpolation(bn,Gt,Wt,jt,rr,ir,or,u.normal);u.normal.dot(l.direction)>0&&u.normal.multiplyScalar(-1),Dn||(u.normal=x)}const c={a:h,b:f,c:g,normal:new U,materialIndex:0};if(Mt.getNormal(Gt,Wt,jt,c.normal),u.face=c,u.faceIndex=h,Dn){const x=new U;Mt.getBarycoord(bn,Gt,Wt,jt,x),u.barycoord=x}}return u}function ar(l){return l&&l.isMaterial?l.side:l}function oe(l,r,i,o,s,h,f){const g=o*3;let p=g+0,y=g+1,a=g+2;const{index:u,groups:c}=l;l.index&&(p=u.getX(p),y=u.getX(y),a=u.getX(a));const{position:x,normal:d,uv:M,uv1:S}=l.attributes;if(Array.isArray(r)){const E=o*3;for(let T=0,e=c.length;T<e;T++){const{start:n,count:v,materialIndex:t}=c[T];if(E>=n&&E<n+v){const P=ar(r[t]),B=sr(i,x,d,M,S,p,y,a,P,h,f);if(B)if(B.faceIndex=o,B.face.materialIndex=t,s)s.push(B);else return B}}}else{const E=ar(r),T=sr(i,x,d,M,S,p,y,a,E,h,f);if(T)if(T.faceIndex=o,T.face.materialIndex=0,s)s.push(T);else return T}return null}function ft(l,r,i,o){const s=l.a,h=l.b,f=l.c;let g=r,p=r+1,y=r+2;i&&(g=i.getX(g),p=i.getX(p),y=i.getX(y)),s.x=o.getX(g),s.y=o.getY(g),s.z=o.getZ(g),h.x=o.getX(p),h.y=o.getY(p),h.z=o.getZ(p),f.x=o.getX(y),f.y=o.getY(y),f.z=o.getZ(y)}function Fi(l,r,i,o,s,h,f,g){const{geometry:p,_indirectBuffer:y}=l;for(let a=o,u=o+s;a<u;a++)oe(p,r,i,a,h,f,g)}function Vi(l,r,i,o,s,h,f){const{geometry:g,_indirectBuffer:p}=l;let y=1/0,a=null;for(let u=o,c=o+s;u<c;u++){let x;x=oe(g,r,i,u,null,h,f),x&&x.distance<y&&(a=x,y=x.distance)}return a}function $i(l,r,i,o,s,h,f){const{geometry:g}=i,{index:p}=g,y=g.attributes.position;for(let a=l,u=r+l;a<u;a++){let c;if(c=a,ft(f,c*3,p,y),f.needsUpdate=!0,o(f,c,s,h))return!0}return!1}function Oi(l,r=null){r&&Array.isArray(r)&&(r=new Set(r));const i=l.geometry,o=i.index?i.index.array:null,s=i.attributes.position;let h,f,g,p,y=0;const a=l._roots;for(let c=0,x=a.length;c<x;c++)h=a[c],f=new Uint32Array(h),g=new Uint16Array(h),p=new Float32Array(h),u(0,y),y+=h.byteLength;function u(c,x,d=!1){const M=c*2;if(pt(M,g)){const S=wt(c,f),E=bt(M,g);let T=1/0,e=1/0,n=1/0,v=-1/0,t=-1/0,P=-1/0;for(let B=3*S,b=3*(S+E);B<b;B++){let w=o[B];const _=s.getX(w),A=s.getY(w),I=s.getZ(w);_<T&&(T=_),_>v&&(v=_),A<e&&(e=A),A>t&&(t=A),I<n&&(n=I),I>P&&(P=I)}return p[c+0]!==T||p[c+1]!==e||p[c+2]!==n||p[c+3]!==v||p[c+4]!==t||p[c+5]!==P?(p[c+0]=T,p[c+1]=e,p[c+2]=n,p[c+3]=v,p[c+4]=t,p[c+5]=P,!0):!1}else{const S=yt(c),E=vt(c,f);let T=d,e=!1,n=!1;if(r){if(!T){const w=S/gt+x/xt,_=E/gt+x/xt;e=r.has(w),n=r.has(_),T=!e&&!n}}else e=!0,n=!0;const v=T||e,t=T||n;let P=!1;v&&(P=u(S,x,T));let B=!1;t&&(B=u(E,x,T));const b=P||B;if(b)for(let w=0;w<3;w++){const _=S+w,A=E+w,I=p[_],C=p[_+3],D=p[A],N=p[A+3];p[c+w]=I<D?I:D,p[c+w+3]=C>N?C:N}return b}}}function qt(l,r,i,o,s){let h,f,g,p,y,a;const u=1/i.direction.x,c=1/i.direction.y,x=1/i.direction.z,d=i.origin.x,M=i.origin.y,S=i.origin.z;let E=r[l],T=r[l+3],e=r[l+1],n=r[l+3+1],v=r[l+2],t=r[l+3+2];return u>=0?(h=(E-d)*u,f=(T-d)*u):(h=(T-d)*u,f=(E-d)*u),c>=0?(g=(e-M)*c,p=(n-M)*c):(g=(n-M)*c,p=(e-M)*c),h>p||g>f||((g>h||isNaN(h))&&(h=g),(p<f||isNaN(f))&&(f=p),x>=0?(y=(v-S)*x,a=(t-S)*x):(y=(t-S)*x,a=(v-S)*x),h>a||y>f)?!1:((y>h||h!==h)&&(h=y),(a<f||f!==f)&&(f=a),h<=s&&f>=o)}function ki(l,r,i,o,s,h,f,g){const{geometry:p,_indirectBuffer:y}=l;for(let a=o,u=o+s;a<u;a++){let c=y?y[a]:a;oe(p,r,i,c,h,f,g)}}function Hi(l,r,i,o,s,h,f){const{geometry:g,_indirectBuffer:p}=l;let y=1/0,a=null;for(let u=o,c=o+s;u<c;u++){let x;x=oe(g,r,i,p?p[u]:u,null,h,f),x&&x.distance<y&&(a=x,y=x.distance)}return a}function qi(l,r,i,o,s,h,f){const{geometry:g}=i,{index:p}=g,y=g.attributes.position;for(let a=l,u=r+l;a<u;a++){let c;if(c=i.resolveTriangleIndex(a),ft(f,c*3,p,y),f.needsUpdate=!0,o(f,c,s,h))return!0}return!1}function Xi(l,r,i,o,s,h,f){nt.setBuffer(l._roots[r]),Re(0,l,i,o,s,h,f),nt.clearBuffer()}function Re(l,r,i,o,s,h,f){const{float32Array:g,uint16Array:p,uint32Array:y}=nt,a=l*2;if(pt(a,p)){const c=wt(l,y),x=bt(a,p);Fi(r,i,o,c,x,s,h,f)}else{const c=yt(l);qt(c,g,o,h,f)&&Re(c,r,i,o,s,h,f);const x=vt(l,y);qt(x,g,o,h,f)&&Re(x,r,i,o,s,h,f)}}const Gi=["x","y","z"];function Wi(l,r,i,o,s,h){nt.setBuffer(l._roots[r]);const f=ze(0,l,i,o,s,h);return nt.clearBuffer(),f}function ze(l,r,i,o,s,h){const{float32Array:f,uint16Array:g,uint32Array:p}=nt;let y=l*2;if(pt(y,g)){const u=wt(l,p),c=bt(y,g);return Vi(r,i,o,u,c,s,h)}else{const u=ke(l,p),c=Gi[u],d=o.direction[c]>=0;let M,S;d?(M=yt(l),S=vt(l,p)):(M=vt(l,p),S=yt(l));const T=qt(M,f,o,s,h)?ze(M,r,i,o,s,h):null;if(T){const v=T.point[c];if(d?v<=f[S+u]:v>=f[S+u+3])return T}const n=qt(S,f,o,s,h)?ze(S,r,i,o,s,h):null;return T&&n?T.distance<=n.distance?T:n:T||n||null}}const Ln=new zt,rn=new Ht,on=new Ht,An=new It,cr=new At,Un=new At;function ji(l,r,i,o){nt.setBuffer(l._roots[r]);const s=Le(0,l,i,o);return nt.clearBuffer(),s}function Le(l,r,i,o,s=null){const{float32Array:h,uint16Array:f,uint32Array:g}=nt;let p=l*2;if(s===null&&(i.boundingBox||i.computeBoundingBox(),cr.set(i.boundingBox.min,i.boundingBox.max,o),s=cr),pt(p,f)){const a=r.geometry,u=a.index,c=a.attributes.position,x=i.index,d=i.attributes.position,M=wt(l,g),S=bt(p,f);if(An.copy(o).invert(),i.boundsTree)return ht(l,h,Un),Un.matrix.copy(An),Un.needsUpdate=!0,i.boundsTree.shapecast({intersectsBounds:T=>Un.intersectsBox(T),intersectsTriangle:T=>{T.a.applyMatrix4(o),T.b.applyMatrix4(o),T.c.applyMatrix4(o),T.needsUpdate=!0;for(let e=M*3,n=(S+M)*3;e<n;e+=3)if(ft(on,e,u,c),on.needsUpdate=!0,T.intersectsTriangle(on))return!0;return!1}});{const E=ie(i);for(let T=M*3,e=(S+M)*3;T<e;T+=3){ft(rn,T,u,c),rn.a.applyMatrix4(An),rn.b.applyMatrix4(An),rn.c.applyMatrix4(An),rn.needsUpdate=!0;for(let n=0,v=E*3;n<v;n+=3)if(ft(on,n,x,d),on.needsUpdate=!0,rn.intersectsTriangle(on))return!0}}}else{const a=yt(l),u=vt(l,g);return ht(a,h,Ln),!!(s.intersectsBox(Ln)&&Le(a,r,i,o,s)||(ht(u,h,Ln),s.intersectsBox(Ln)&&Le(u,r,i,o,s)))}}const Fn=new It,pe=new At,_n=new At,Yi=new U,Zi=new U,Ki=new U,Ji=new U;function Qi(l,r,i,o={},s={},h=0,f=1/0){r.boundingBox||r.computeBoundingBox(),pe.set(r.boundingBox.min,r.boundingBox.max,i),pe.needsUpdate=!0;const g=l.geometry,p=g.attributes.position,y=g.index,a=r.attributes.position,u=r.index,c=Et.getPrimitive(),x=Et.getPrimitive();let d=Yi,M=Zi,S=null,E=null;s&&(S=Ki,E=Ji);let T=1/0,e=null,n=null;return Fn.copy(i).invert(),_n.matrix.copy(Fn),l.shapecast({boundsTraverseOrder:v=>pe.distanceToBox(v),intersectsBounds:(v,t,P)=>P<T&&P<f?(t&&(_n.min.copy(v.min),_n.max.copy(v.max),_n.needsUpdate=!0),!0):!1,intersectsRange:(v,t)=>{if(r.boundsTree)return r.boundsTree.shapecast({boundsTraverseOrder:B=>_n.distanceToBox(B),intersectsBounds:(B,b,w)=>w<T&&w<f,intersectsRange:(B,b)=>{for(let w=B,_=B+b;w<_;w++){ft(x,3*w,u,a),x.a.applyMatrix4(i),x.b.applyMatrix4(i),x.c.applyMatrix4(i),x.needsUpdate=!0;for(let A=v,I=v+t;A<I;A++){ft(c,3*A,y,p),c.needsUpdate=!0;const C=c.distanceToTriangle(x,d,S);if(C<T&&(M.copy(d),E&&E.copy(S),T=C,e=A,n=w),C<h)return!0}}}});{const P=ie(r);for(let B=0,b=P;B<b;B++){ft(x,3*B,u,a),x.a.applyMatrix4(i),x.b.applyMatrix4(i),x.c.applyMatrix4(i),x.needsUpdate=!0;for(let w=v,_=v+t;w<_;w++){ft(c,3*w,y,p),c.needsUpdate=!0;const A=c.distanceToTriangle(x,d,S);if(A<T&&(M.copy(d),E&&E.copy(S),T=A,e=w,n=B),A<h)return!0}}}}}),Et.releasePrimitive(c),Et.releasePrimitive(x),T===1/0?null:(o.point?o.point.copy(M):o.point=M.clone(),o.distance=T,o.faceIndex=e,s&&(s.point?s.point.copy(E):s.point=E.clone(),s.point.applyMatrix4(Fn),M.applyMatrix4(Fn),s.distance=M.sub(s.point).length(),s.faceIndex=n),o)}function mi(l,r=null){r&&Array.isArray(r)&&(r=new Set(r));const i=l.geometry,o=i.index?i.index.array:null,s=i.attributes.position;let h,f,g,p,y=0;const a=l._roots;for(let c=0,x=a.length;c<x;c++)h=a[c],f=new Uint32Array(h),g=new Uint16Array(h),p=new Float32Array(h),u(0,y),y+=h.byteLength;function u(c,x,d=!1){const M=c*2;if(pt(M,g)){const S=wt(c,f),E=bt(M,g);let T=1/0,e=1/0,n=1/0,v=-1/0,t=-1/0,P=-1/0;for(let B=S,b=S+E;B<b;B++){const w=3*l.resolveTriangleIndex(B);for(let _=0;_<3;_++){let A=w+_;A=o?o[A]:A;const I=s.getX(A),C=s.getY(A),D=s.getZ(A);I<T&&(T=I),I>v&&(v=I),C<e&&(e=C),C>t&&(t=C),D<n&&(n=D),D>P&&(P=D)}}return p[c+0]!==T||p[c+1]!==e||p[c+2]!==n||p[c+3]!==v||p[c+4]!==t||p[c+5]!==P?(p[c+0]=T,p[c+1]=e,p[c+2]=n,p[c+3]=v,p[c+4]=t,p[c+5]=P,!0):!1}else{const S=yt(c),E=vt(c,f);let T=d,e=!1,n=!1;if(r){if(!T){const w=S/gt+x/xt,_=E/gt+x/xt;e=r.has(w),n=r.has(_),T=!e&&!n}}else e=!0,n=!0;const v=T||e,t=T||n;let P=!1;v&&(P=u(S,x,T));let B=!1;t&&(B=u(E,x,T));const b=P||B;if(b)for(let w=0;w<3;w++){const _=S+w,A=E+w,I=p[_],C=p[_+3],D=p[A],N=p[A+3];p[c+w]=I<D?I:D,p[c+w+3]=C>N?C:N}return b}}}function to(l,r,i,o,s,h,f){nt.setBuffer(l._roots[r]),Ue(0,l,i,o,s,h,f),nt.clearBuffer()}function Ue(l,r,i,o,s,h,f){const{float32Array:g,uint16Array:p,uint32Array:y}=nt,a=l*2;if(pt(a,p)){const c=wt(l,y),x=bt(a,p);ki(r,i,o,c,x,s,h,f)}else{const c=yt(l);qt(c,g,o,h,f)&&Ue(c,r,i,o,s,h,f);const x=vt(l,y);qt(x,g,o,h,f)&&Ue(x,r,i,o,s,h,f)}}const no=["x","y","z"];function eo(l,r,i,o,s,h){nt.setBuffer(l._roots[r]);const f=Fe(0,l,i,o,s,h);return nt.clearBuffer(),f}function Fe(l,r,i,o,s,h){const{float32Array:f,uint16Array:g,uint32Array:p}=nt;let y=l*2;if(pt(y,g)){const u=wt(l,p),c=bt(y,g);return Hi(r,i,o,u,c,s,h)}else{const u=ke(l,p),c=no[u],d=o.direction[c]>=0;let M,S;d?(M=yt(l),S=vt(l,p)):(M=vt(l,p),S=yt(l));const T=qt(M,f,o,s,h)?Fe(M,r,i,o,s,h):null;if(T){const v=T.point[c];if(d?v<=f[S+u]:v>=f[S+u+3])return T}const n=qt(S,f,o,s,h)?Fe(S,r,i,o,s,h):null;return T&&n?T.distance<=n.distance?T:n:T||n||null}}const Vn=new zt,sn=new Ht,an=new Ht,Bn=new It,lr=new At,$n=new At;function ro(l,r,i,o){nt.setBuffer(l._roots[r]);const s=Ve(0,l,i,o);return nt.clearBuffer(),s}function Ve(l,r,i,o,s=null){const{float32Array:h,uint16Array:f,uint32Array:g}=nt;let p=l*2;if(s===null&&(i.boundingBox||i.computeBoundingBox(),lr.set(i.boundingBox.min,i.boundingBox.max,o),s=lr),pt(p,f)){const a=r.geometry,u=a.index,c=a.attributes.position,x=i.index,d=i.attributes.position,M=wt(l,g),S=bt(p,f);if(Bn.copy(o).invert(),i.boundsTree)return ht(l,h,$n),$n.matrix.copy(Bn),$n.needsUpdate=!0,i.boundsTree.shapecast({intersectsBounds:T=>$n.intersectsBox(T),intersectsTriangle:T=>{T.a.applyMatrix4(o),T.b.applyMatrix4(o),T.c.applyMatrix4(o),T.needsUpdate=!0;for(let e=M,n=S+M;e<n;e++)if(ft(an,3*r.resolveTriangleIndex(e),u,c),an.needsUpdate=!0,T.intersectsTriangle(an))return!0;return!1}});{const E=ie(i);for(let T=M,e=S+M;T<e;T++){const n=r.resolveTriangleIndex(T);ft(sn,3*n,u,c),sn.a.applyMatrix4(Bn),sn.b.applyMatrix4(Bn),sn.c.applyMatrix4(Bn),sn.needsUpdate=!0;for(let v=0,t=E*3;v<t;v+=3)if(ft(an,v,x,d),an.needsUpdate=!0,sn.intersectsTriangle(an))return!0}}}else{const a=yt(l),u=vt(l,g);return ht(a,h,Vn),!!(s.intersectsBox(Vn)&&Ve(a,r,i,o,s)||(ht(u,h,Vn),s.intersectsBox(Vn)&&Ve(u,r,i,o,s)))}}const On=new It,ye=new At,Tn=new At,io=new U,oo=new U,so=new U,ao=new U;function co(l,r,i,o={},s={},h=0,f=1/0){r.boundingBox||r.computeBoundingBox(),ye.set(r.boundingBox.min,r.boundingBox.max,i),ye.needsUpdate=!0;const g=l.geometry,p=g.attributes.position,y=g.index,a=r.attributes.position,u=r.index,c=Et.getPrimitive(),x=Et.getPrimitive();let d=io,M=oo,S=null,E=null;s&&(S=so,E=ao);let T=1/0,e=null,n=null;return On.copy(i).invert(),Tn.matrix.copy(On),l.shapecast({boundsTraverseOrder:v=>ye.distanceToBox(v),intersectsBounds:(v,t,P)=>P<T&&P<f?(t&&(Tn.min.copy(v.min),Tn.max.copy(v.max),Tn.needsUpdate=!0),!0):!1,intersectsRange:(v,t)=>{if(r.boundsTree){const P=r.boundsTree;return P.shapecast({boundsTraverseOrder:B=>Tn.distanceToBox(B),intersectsBounds:(B,b,w)=>w<T&&w<f,intersectsRange:(B,b)=>{for(let w=B,_=B+b;w<_;w++){const A=P.resolveTriangleIndex(w);ft(x,3*A,u,a),x.a.applyMatrix4(i),x.b.applyMatrix4(i),x.c.applyMatrix4(i),x.needsUpdate=!0;for(let I=v,C=v+t;I<C;I++){const D=l.resolveTriangleIndex(I);ft(c,3*D,y,p),c.needsUpdate=!0;const N=c.distanceToTriangle(x,d,S);if(N<T&&(M.copy(d),E&&E.copy(S),T=N,e=I,n=w),N<h)return!0}}}})}else{const P=ie(r);for(let B=0,b=P;B<b;B++){ft(x,3*B,u,a),x.a.applyMatrix4(i),x.b.applyMatrix4(i),x.c.applyMatrix4(i),x.needsUpdate=!0;for(let w=v,_=v+t;w<_;w++){const A=l.resolveTriangleIndex(w);ft(c,3*A,y,p),c.needsUpdate=!0;const I=c.distanceToTriangle(x,d,S);if(I<T&&(M.copy(d),E&&E.copy(S),T=I,e=w,n=B),I<h)return!0}}}}}),Et.releasePrimitive(c),Et.releasePrimitive(x),T===1/0?null:(o.point?o.point.copy(M):o.point=M.clone(),o.distance=T,o.faceIndex=e,s&&(s.point?s.point.copy(E):s.point=E.clone(),s.point.applyMatrix4(On),M.applyMatrix4(On),s.distance=M.sub(s.point).length(),s.faceIndex=n),o)}function ur(l,r,i){return l===null?null:(l.point.applyMatrix4(r.matrixWorld),l.distance=l.point.distanceTo(i.ray.origin),l.object=r,l)}const kn=new At,Hn=new $e,hr=new U,fr=new It,gr=new U,ve=["getX","getY","getZ"];class ee extends Ni{static serialize(r,i={}){i={cloneBuffers:!0,...i};const o=r.geometry,s=r._roots,h=r._indirectBuffer,f=o.getIndex(),g={version:1,roots:null,index:null,indirectBuffer:null};return i.cloneBuffers?(g.roots=s.map(p=>p.slice()),g.index=f?f.array.slice():null,g.indirectBuffer=h?h.slice():null):(g.roots=s,g.index=f?f.array:null,g.indirectBuffer=h),g}static deserialize(r,i,o={}){o={setIndex:!0,indirect:!!r.indirectBuffer,...o};const{index:s,roots:h,indirectBuffer:f}=r;r.version||(console.warn("MeshBVH.deserialize: Serialization format has been changed and will be fixed up. It is recommended to regenerate any stored serialized data."),p(h));const g=new ee(i,{...o,[Oe]:!0});if(g._roots=h,g._indirectBuffer=f||null,o.setIndex){const y=i.getIndex();if(y===null){const a=new te(r.index,1,!1);i.setIndex(a)}else y.array!==s&&(y.array.set(s),y.needsUpdate=!0)}return g;function p(y){for(let a=0;a<y.length;a++){const u=y[a],c=new Uint32Array(u),x=new Uint16Array(u);for(let d=0,M=u.byteLength/xt;d<M;d++){const S=gt*d,E=2*S;pt(E,x)||(c[S+6]=c[S+6]/gt-d)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(r,i={}){i.maxLeafTris&&(console.warn('MeshBVH: "maxLeafTris" option has been deprecated. Use maxLeafSize, instead.'),i={...i,maxLeafSize:i.maxLeafTris}),super(r,i)}shiftTriangleOffsets(r){return super.shiftPrimitiveOffsets(r)}writePrimitiveBounds(r,i,o){const s=this.geometry,h=this._indirectBuffer,f=s.attributes.position,g=s.index?s.index.array:null,y=(h?h[r]:r)*3;let a=y+0,u=y+1,c=y+2;g&&(a=g[a],u=g[u],c=g[c]);for(let x=0;x<3;x++){const d=f[ve[x]](a),M=f[ve[x]](u),S=f[ve[x]](c);let E=d;M<E&&(E=M),S<E&&(E=S);let T=d;M>T&&(T=M),S>T&&(T=S),i[o+x]=E,i[o+x+3]=T}return i}computePrimitiveBounds(r,i,o){const s=this.geometry,h=this._indirectBuffer,f=s.attributes.position,g=s.index?s.index.array:null,p=f.normalized;if(r<0||i+r-o.offset>o.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const y=f.array,a=f.offset||0;let u=3;f.isInterleavedBufferAttribute&&(u=f.data.stride);const c=["getX","getY","getZ"],x=o.offset;for(let d=r,M=r+i;d<M;d++){const E=(h?h[d]:d)*3,T=(d-x)*6;let e=E+0,n=E+1,v=E+2;g&&(e=g[e],n=g[n],v=g[v]),p||(e=e*u+a,n=n*u+a,v=v*u+a);for(let t=0;t<3;t++){let P,B,b;p?(P=f[c[t]](e),B=f[c[t]](n),b=f[c[t]](v)):(P=y[e+t],B=y[n+t],b=y[v+t]);let w=P;B<w&&(w=B),b<w&&(w=b);let _=P;B>_&&(_=B),b>_&&(_=b);const A=(_-w)/2,I=t*2;o[T+I+0]=w+A,o[T+I+1]=A+(Math.abs(w)+A)*Zn}}return o}raycastObject3D(r,i,o=[]){const{material:s}=r;if(s===void 0)return;fr.copy(r.matrixWorld).invert(),Hn.copy(i.ray).applyMatrix4(fr),gr.setFromMatrixScale(r.matrixWorld),hr.copy(Hn.direction).multiply(gr);const h=hr.length(),f=i.near/h,g=i.far/h;if(i.firstHitOnly===!0){let p=this.raycastFirst(Hn,s,f,g);p=ur(p,r,i),p&&o.push(p)}else{const p=this.raycast(Hn,s,f,g);for(let y=0,a=p.length;y<a;y++){const u=ur(p[y],r,i);u&&o.push(u)}}return o}refit(r=null){return(this.indirect?mi:Oi)(this,r)}raycast(r,i=Ye,o=0,s=1/0){const h=this._roots,f=[],g=this.indirect?to:Xi;for(let p=0,y=h.length;p<y;p++)g(this,p,i,r,f,o,s);return f}raycastFirst(r,i=Ye,o=0,s=1/0){const h=this._roots;let f=null;const g=this.indirect?eo:Wi;for(let p=0,y=h.length;p<y;p++){const a=g(this,p,i,r,o,s);a!=null&&(f==null||a.distance<f.distance)&&(f=a)}return f}intersectsGeometry(r,i){let o=!1;const s=this._roots,h=this.indirect?ro:ji;for(let f=0,g=s.length;f<g&&(o=h(this,f,r,i),!o);f++);return o}shapecast(r){const i=Et.getPrimitive(),o=super.shapecast({...r,intersectsPrimitive:r.intersectsTriangle,scratchPrimitive:i,iterate:this.indirect?qi:$i});return Et.releasePrimitive(i),o}bvhcast(r,i,o){let{intersectsRanges:s,intersectsTriangles:h}=o;const f=Et.getPrimitive(),g=this.geometry.index,p=this.geometry.attributes.position,y=this.indirect?d=>{const M=this.resolveTriangleIndex(d);ft(f,M*3,g,p)}:d=>{ft(f,d*3,g,p)},a=Et.getPrimitive(),u=r.geometry.index,c=r.geometry.attributes.position,x=r.indirect?d=>{const M=r.resolveTriangleIndex(d);ft(a,M*3,u,c)}:d=>{ft(a,d*3,u,c)};if(h){if(!(r instanceof ee))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const d=(M,S,E,T,e,n,v,t)=>{for(let P=E,B=E+T;P<B;P++){x(P),a.a.applyMatrix4(i),a.b.applyMatrix4(i),a.c.applyMatrix4(i),a.needsUpdate=!0;for(let b=M,w=M+S;b<w;b++)if(y(b),f.needsUpdate=!0,h(f,a,b,P,e,n,v,t))return!0}return!1};if(s){const M=s;s=function(S,E,T,e,n,v,t,P){return M(S,E,T,e,n,v,t,P)?!0:d(S,E,T,e,n,v,t,P)}}else s=d}return super.bvhcast(r,i,{intersectsRanges:s})}intersectsBox(r,i){return kn.set(r.min,r.max,i),kn.needsUpdate=!0,this.shapecast({intersectsBounds:o=>kn.intersectsBox(o),intersectsTriangle:o=>kn.intersectsTriangle(o)})}intersectsSphere(r){return this.shapecast({intersectsBounds:i=>r.intersectsBox(i),intersectsTriangle:i=>i.intersectsSphere(r)})}closestPointToGeometry(r,i,o={},s={},h=0,f=1/0){return(this.indirect?co:Qi)(this,r,i,o,s,h,f)}closestPointToPoint(r,i={},o=0,s=1/0){return zi(this,r,i,o,s)}}const Zr=1e-6,lo=Zr*.5,Kr=Math.pow(10,-Math.log10(Zr)),uo=lo*Kr;function Rt(l){return~~(l*Kr+uo)}function ho(l){return`${Rt(l.x)},${Rt(l.y)}`}function pr(l){return`${Rt(l.x)},${Rt(l.y)},${Rt(l.z)}`}function fo(l){return`${Rt(l.x)},${Rt(l.y)},${Rt(l.z)},${Rt(l.w)}`}function go(l,r,i){i.direction.subVectors(r,l).normalize();const o=l.dot(i.direction);return i.origin.copy(l).addScaledVector(i.direction,-o),i}function Jr(){return typeof SharedArrayBuffer<"u"}function po(l){if(l.buffer instanceof SharedArrayBuffer)return l;const r=l.constructor,i=l.buffer,o=new SharedArrayBuffer(i.byteLength),s=new Uint8Array(i);return new Uint8Array(o).set(s,0),new r(o)}function yo(l){return l.index?l.index.count:l.attributes.position.count}function Xe(l){return yo(l)/3}const vo=1e-8,xo=new U;function wo(l){return~~(l/3)}function bo(l){return l%3}function yr(l,r){return l.start-r.start}function vr(l,r){return xo.subVectors(r,l.origin).dot(l.direction)}function Ao(l,r,i,o=vo){l.sort(yr),r.sort(yr);for(let g=0;g<l.length;g++){const p=l[g];for(let y=0;y<r.length;y++){const a=r[y];if(!(a.start>p.end)){if(p.end<a.start||a.end<p.start)continue;if(p.start<=a.start&&p.end>=a.end)h(a.end,p.end)||l.splice(g+1,0,{start:a.end,end:p.end,index:p.index}),p.end=a.start,a.start=0,a.end=0;else if(p.start>=a.start&&p.end<=a.end)h(p.end,a.end)||r.splice(y+1,0,{start:p.end,end:a.end,index:a.index}),a.end=p.start,p.start=0,p.end=0;else if(p.start<=a.start&&p.end<=a.end){const u=p.end;p.end=a.start,a.start=u}else if(p.start>=a.start&&p.end>=a.end){const u=a.end;a.end=p.start,p.start=u}else throw new Error}if(i.has(p.index)||i.set(p.index,[]),i.has(a.index)||i.set(a.index,[]),i.get(p.index).push(a.index),i.get(a.index).push(p.index),f(a)&&(r.splice(y,1),y--),f(p)){l.splice(g,1),g--;break}}}s(l),s(r);function s(g){for(let p=0;p<g.length;p++)f(g[p])&&(g.splice(p,1),p--)}function h(g,p){return Math.abs(p-g)<o}function f(g){return Math.abs(g.end-g.start)<o}}const xr=1e-5,wr=1e-4;class _o{constructor(){this._rays=[]}addRay(r){this._rays.push(r)}findClosestRay(r){const i=this._rays,o=r.clone();o.direction.multiplyScalar(-1);let s=1/0,h=null;for(let p=0,y=i.length;p<y;p++){const a=i[p];if(f(a,r)&&f(a,o))continue;const u=g(a,r),c=g(a,o),x=Math.min(u,c);x<s&&(s=x,h=a)}return h;function f(p,y){const a=p.origin.distanceTo(y.origin)>xr;return p.direction.angleTo(y.direction)>wr||a}function g(p,y){const a=p.origin.distanceTo(y.origin),u=p.direction.angleTo(y.direction);return a/xr+u/wr}}}const xe=new U,we=new U,qn=new $e;function Bo(l,r,i){const o=l.attributes,s=l.index,h=o.position,f=new Map,g=new Map,p=Array.from(r),y=new _o;for(let a=0,u=p.length;a<u;a++){const c=p[a],x=wo(c),d=bo(c);let M=3*x+d,S=3*x+(d+1)%3;s&&(M=s.getX(M),S=s.getX(S)),xe.fromBufferAttribute(h,M),we.fromBufferAttribute(h,S),go(xe,we,qn);let E,T=y.findClosestRay(qn);T===null&&(T=qn.clone(),y.addRay(T)),g.has(T)||g.set(T,{forward:[],reverse:[],ray:T}),E=g.get(T);let e=vr(T,xe),n=vr(T,we);e>n&&([e,n]=[n,e]),qn.direction.dot(T.direction)<0?E.reverse.push({start:e,end:n,index:c}):E.forward.push({start:e,end:n,index:c})}return g.forEach(({forward:a,reverse:u},c)=>{Ao(a,u,f,i),a.length===0&&u.length===0&&g.delete(c)}),{disjointConnectivityMap:f,fragmentMap:g}}const To=new pn,be=new U,Io=new Mn,Ae=["","",""];class So{constructor(){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8}getSiblingTriangleIndex(r,i){const o=this.data[r*3+i];return o===-1?-1:~~(o/3)}getSiblingEdgeIndex(r,i){const o=this.data[r*3+i];return o===-1?-1:o%3}getDisjointSiblingTriangleIndices(r,i){const o=r*3+i,s=this.disjointConnections.get(o);return s?s.map(h=>~~(h/3)):[]}getDisjointSiblingEdgeIndices(r,i){const o=r*3+i,s=this.disjointConnections.get(o);return s?s.map(h=>h%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(r){const{useAllAttributes:i,useDrawRange:o,matchDisjointEdges:s,degenerateEpsilon:h}=this,f=i?e:T,g=new Map,{attributes:p}=r,y=i?Object.keys(p):null,a=r.index,u=p.position;let c=Xe(r);const x=c;let d=0;o&&(d=r.drawRange.start,r.drawRange.count!==1/0&&(c=~~(r.drawRange.count/3)));let M=this.data;(!M||M.length<3*x)&&(M=new Int32Array(3*x)),M.fill(-1);let S=0,E=new Set;for(let n=d,v=c*3+d;n<v;n+=3){const t=n;for(let P=0;P<3;P++){let B=t+P;a&&(B=a.getX(B)),Ae[P]=f(B)}for(let P=0;P<3;P++){const B=(P+1)%3,b=Ae[P],w=Ae[B],_=`${w}_${b}`;if(g.has(_)){const A=t+P,I=g.get(_);M[A]=I,M[I]=A,g.delete(_),S+=2,E.delete(I)}else{const A=`${b}_${w}`,I=t+P;g.set(A,I),E.add(I)}}}if(s){const{fragmentMap:n,disjointConnectivityMap:v}=Bo(r,E,h);E.clear(),n.forEach(({forward:t,reverse:P})=>{t.forEach(({index:B})=>E.add(B)),P.forEach(({index:B})=>E.add(B))}),this.unmatchedDisjointEdges=n,this.disjointConnections=v,S=c*3-E.size}this.matchedEdges=S,this.unmatchedEdges=E.size,this.data=M;function T(n){return be.fromBufferAttribute(u,n),pr(be)}function e(n){let v="";for(let t=0,P=y.length;t<P;t++){const B=p[y[t]];let b;switch(B.itemSize){case 1:b=Rt(B.getX(n));break;case 2:b=ho(To.fromBufferAttribute(B,n));break;case 3:b=pr(be.fromBufferAttribute(B,n));break;case 4:b=fo(Io.fromBufferAttribute(B,n));break}v!==""&&(v+="|"),v+=b}return v}}}class br extends li{constructor(...r){super(...r),this.isBrush=!0,this._previousMatrix=new It,this._previousMatrix.elements.fill(0),this._halfEdges=null,this._boundsTree=null,this._groupIndices=null,this._hash=null}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:r,_previousMatrix:i}=this,o=r.elements,s=i.elements;for(let h=0;h<16;h++)if(o[h]!==s[h])return!0;return!1}prepareGeometry(){const r=this.geometry,i=r.attributes,o=Jr(),s=r.index,h=r.attributes.position,f=s?`${s.uuid}_${s.count}_${s.version}`:"-1_-1_-1",g=`${h.uuid}_${h.count}_${h.version}`,p=`${r.uuid}_${f}_${g}`;if(this._hash===p)return;if(this._hash=p,o)for(const c in i){const x=i[c];if(x.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");x.array=po(x.array)}r.boundsTree=new ee(r,{maxLeafSize:3,indirect:!0,useSharedArrayBuffer:o}),r.halfEdges||(r.halfEdges=new So),r.halfEdges.updateFrom(r);const y=Xe(r);(!r.groupIndices||r.groupIndices.length!==y)&&(r.groupIndices=new Uint16Array(y));const a=r.groupIndices,u=r.groups;for(let c=0,x=u.length;c<x;c++){const{start:d,count:M}=u[c];for(let S=d/3,E=(d+M)/3;S<E;S++)a[S]=c}}disposeCacheData(){const{geometry:r}=this;r.halfEdges=null,r.boundsTree=null,r.groupIndices=null}}var Mo=Object.getOwnPropertyNames,dt=(l,r)=>function(){return r||(0,l[Mo(l)[0]])((r={exports:{}}).exports,r),r.exports},se=dt({"node_modules/binary-search-bounds/search-bounds.js"(l,r){function i(p,y,a,u,c){for(var x=c+1;u<=c;){var d=u+c>>>1,M=p[d],S=a!==void 0?a(M,y):M-y;S>=0?(x=d,c=d-1):u=d+1}return x}function o(p,y,a,u,c){for(var x=c+1;u<=c;){var d=u+c>>>1,M=p[d],S=a!==void 0?a(M,y):M-y;S>0?(x=d,c=d-1):u=d+1}return x}function s(p,y,a,u,c){for(var x=u-1;u<=c;){var d=u+c>>>1,M=p[d],S=a!==void 0?a(M,y):M-y;S<0?(x=d,u=d+1):c=d-1}return x}function h(p,y,a,u,c){for(var x=u-1;u<=c;){var d=u+c>>>1,M=p[d],S=a!==void 0?a(M,y):M-y;S<=0?(x=d,u=d+1):c=d-1}return x}function f(p,y,a,u,c){for(;u<=c;){var x=u+c>>>1,d=p[x],M=a!==void 0?a(d,y):d-y;if(M===0)return x;M<=0?u=x+1:c=x-1}return-1}function g(p,y,a,u,c,x){return typeof a=="function"?x(p,y,a,u===void 0?0:u|0,c===void 0?p.length-1:c|0):x(p,y,void 0,a===void 0?0:a|0,u===void 0?p.length-1:u|0)}r.exports={ge:function(p,y,a,u,c){return g(p,y,a,u,c,i)},gt:function(p,y,a,u,c){return g(p,y,a,u,c,o)},lt:function(p,y,a,u,c){return g(p,y,a,u,c,s)},le:function(p,y,a,u,c){return g(p,y,a,u,c,h)},eq:function(p,y,a,u,c){return g(p,y,a,u,c,f)}}}}),Ge=dt({"node_modules/two-product/two-product.js"(l,r){r.exports=o;var i=+(Math.pow(2,27)+1);function o(s,h,f){var g=s*h,p=i*s,y=p-s,a=p-y,u=s-a,c=i*h,x=c-h,d=c-x,M=h-d,S=g-a*d,E=S-u*d,T=E-a*M,e=u*M-T;return f?(f[0]=e,f[1]=g,f):[e,g]}}}),Qr=dt({"node_modules/robust-sum/robust-sum.js"(l,r){r.exports=o;function i(s,h){var f=s+h,g=f-s,p=f-g,y=h-g,a=s-p,u=a+y;return u?[u,f]:[f]}function o(s,h){var f=s.length|0,g=h.length|0;if(f===1&&g===1)return i(s[0],h[0]);var p=f+g,y=new Array(p),a=0,u=0,c=0,x=Math.abs,d=s[u],M=x(d),S=h[c],E=x(S),T,e;M<E?(e=d,u+=1,u<f&&(d=s[u],M=x(d))):(e=S,c+=1,c<g&&(S=h[c],E=x(S))),u<f&&M<E||c>=g?(T=d,u+=1,u<f&&(d=s[u],M=x(d))):(T=S,c+=1,c<g&&(S=h[c],E=x(S)));for(var n=T+e,v=n-T,t=e-v,P=t,B=n,b,w,_,A,I;u<f&&c<g;)M<E?(T=d,u+=1,u<f&&(d=s[u],M=x(d))):(T=S,c+=1,c<g&&(S=h[c],E=x(S))),e=P,n=T+e,v=n-T,t=e-v,t&&(y[a++]=t),b=B+n,w=b-B,_=b-w,A=n-w,I=B-_,P=I+A,B=b;for(;u<f;)T=d,e=P,n=T+e,v=n-T,t=e-v,t&&(y[a++]=t),b=B+n,w=b-B,_=b-w,A=n-w,I=B-_,P=I+A,B=b,u+=1,u<f&&(d=s[u]);for(;c<g;)T=S,e=P,n=T+e,v=n-T,t=e-v,t&&(y[a++]=t),b=B+n,w=b-B,_=b-w,A=n-w,I=B-_,P=I+A,B=b,c+=1,c<g&&(S=h[c]);return P&&(y[a++]=P),B&&(y[a++]=B),a||(y[a++]=0),y.length=a,y}}}),Eo=dt({"node_modules/two-sum/two-sum.js"(l,r){r.exports=i;function i(o,s,h){var f=o+s,g=f-o,p=f-g,y=s-g,a=o-p;return h?(h[0]=a+y,h[1]=f,h):[a+y,f]}}}),mr=dt({"node_modules/robust-scale/robust-scale.js"(l,r){var i=Ge(),o=Eo();r.exports=s;function s(h,f){var g=h.length;if(g===1){var p=i(h[0],f);return p[0]?p:[p[1]]}var y=new Array(2*g),a=[.1,.1],u=[.1,.1],c=0;i(h[0],f,a),a[0]&&(y[c++]=a[0]);for(var x=1;x<g;++x){i(h[x],f,u);var d=a[1];o(d,u[0],a),a[0]&&(y[c++]=a[0]);var M=u[1],S=a[1],E=M+S,T=E-M,e=S-T;a[1]=E,e&&(y[c++]=e)}return a[1]&&(y[c++]=a[1]),c===0&&(y[c++]=0),y.length=c,y}}}),ti=dt({"node_modules/robust-subtract/robust-diff.js"(l,r){r.exports=o;function i(s,h){var f=s+h,g=f-s,p=f-g,y=h-g,a=s-p,u=a+y;return u?[u,f]:[f]}function o(s,h){var f=s.length|0,g=h.length|0;if(f===1&&g===1)return i(s[0],-h[0]);var p=f+g,y=new Array(p),a=0,u=0,c=0,x=Math.abs,d=s[u],M=x(d),S=-h[c],E=x(S),T,e;M<E?(e=d,u+=1,u<f&&(d=s[u],M=x(d))):(e=S,c+=1,c<g&&(S=-h[c],E=x(S))),u<f&&M<E||c>=g?(T=d,u+=1,u<f&&(d=s[u],M=x(d))):(T=S,c+=1,c<g&&(S=-h[c],E=x(S)));for(var n=T+e,v=n-T,t=e-v,P=t,B=n,b,w,_,A,I;u<f&&c<g;)M<E?(T=d,u+=1,u<f&&(d=s[u],M=x(d))):(T=S,c+=1,c<g&&(S=-h[c],E=x(S))),e=P,n=T+e,v=n-T,t=e-v,t&&(y[a++]=t),b=B+n,w=b-B,_=b-w,A=n-w,I=B-_,P=I+A,B=b;for(;u<f;)T=d,e=P,n=T+e,v=n-T,t=e-v,t&&(y[a++]=t),b=B+n,w=b-B,_=b-w,A=n-w,I=B-_,P=I+A,B=b,u+=1,u<f&&(d=s[u]);for(;c<g;)T=S,e=P,n=T+e,v=n-T,t=e-v,t&&(y[a++]=t),b=B+n,w=b-B,_=b-w,A=n-w,I=B-_,P=I+A,B=b,c+=1,c<g&&(S=-h[c]);return P&&(y[a++]=P),B&&(y[a++]=B),a||(y[a++]=0),y.length=a,y}}}),Po=dt({"node_modules/robust-orientation/orientation.js"(l,r){var i=Ge(),o=Qr(),s=mr(),h=ti(),f=5,g=11102230246251565e-32,p=(3+16*g)*g,y=(7+56*g)*g;function a(n,v,t,P){return function(b,w,_){var A=n(n(v(w[1],_[0]),v(-_[1],w[0])),n(v(b[1],w[0]),v(-w[1],b[0]))),I=n(v(b[1],_[0]),v(-_[1],b[0])),C=P(A,I);return C[C.length-1]}}function u(n,v,t,P){return function(b,w,_,A){var I=n(n(t(n(v(_[1],A[0]),v(-A[1],_[0])),w[2]),n(t(n(v(w[1],A[0]),v(-A[1],w[0])),-_[2]),t(n(v(w[1],_[0]),v(-_[1],w[0])),A[2]))),n(t(n(v(w[1],A[0]),v(-A[1],w[0])),b[2]),n(t(n(v(b[1],A[0]),v(-A[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),A[2])))),C=n(n(t(n(v(_[1],A[0]),v(-A[1],_[0])),b[2]),n(t(n(v(b[1],A[0]),v(-A[1],b[0])),-_[2]),t(n(v(b[1],_[0]),v(-_[1],b[0])),A[2]))),n(t(n(v(w[1],_[0]),v(-_[1],w[0])),b[2]),n(t(n(v(b[1],_[0]),v(-_[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),_[2])))),D=P(I,C);return D[D.length-1]}}function c(n,v,t,P){return function(b,w,_,A,I){var C=n(n(n(t(n(t(n(v(A[1],I[0]),v(-I[1],A[0])),_[2]),n(t(n(v(_[1],I[0]),v(-I[1],_[0])),-A[2]),t(n(v(_[1],A[0]),v(-A[1],_[0])),I[2]))),w[3]),n(t(n(t(n(v(A[1],I[0]),v(-I[1],A[0])),w[2]),n(t(n(v(w[1],I[0]),v(-I[1],w[0])),-A[2]),t(n(v(w[1],A[0]),v(-A[1],w[0])),I[2]))),-_[3]),t(n(t(n(v(_[1],I[0]),v(-I[1],_[0])),w[2]),n(t(n(v(w[1],I[0]),v(-I[1],w[0])),-_[2]),t(n(v(w[1],_[0]),v(-_[1],w[0])),I[2]))),A[3]))),n(t(n(t(n(v(_[1],A[0]),v(-A[1],_[0])),w[2]),n(t(n(v(w[1],A[0]),v(-A[1],w[0])),-_[2]),t(n(v(w[1],_[0]),v(-_[1],w[0])),A[2]))),-I[3]),n(t(n(t(n(v(A[1],I[0]),v(-I[1],A[0])),w[2]),n(t(n(v(w[1],I[0]),v(-I[1],w[0])),-A[2]),t(n(v(w[1],A[0]),v(-A[1],w[0])),I[2]))),b[3]),t(n(t(n(v(A[1],I[0]),v(-I[1],A[0])),b[2]),n(t(n(v(b[1],I[0]),v(-I[1],b[0])),-A[2]),t(n(v(b[1],A[0]),v(-A[1],b[0])),I[2]))),-w[3])))),n(n(t(n(t(n(v(w[1],I[0]),v(-I[1],w[0])),b[2]),n(t(n(v(b[1],I[0]),v(-I[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),I[2]))),A[3]),n(t(n(t(n(v(w[1],A[0]),v(-A[1],w[0])),b[2]),n(t(n(v(b[1],A[0]),v(-A[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),A[2]))),-I[3]),t(n(t(n(v(_[1],A[0]),v(-A[1],_[0])),w[2]),n(t(n(v(w[1],A[0]),v(-A[1],w[0])),-_[2]),t(n(v(w[1],_[0]),v(-_[1],w[0])),A[2]))),b[3]))),n(t(n(t(n(v(_[1],A[0]),v(-A[1],_[0])),b[2]),n(t(n(v(b[1],A[0]),v(-A[1],b[0])),-_[2]),t(n(v(b[1],_[0]),v(-_[1],b[0])),A[2]))),-w[3]),n(t(n(t(n(v(w[1],A[0]),v(-A[1],w[0])),b[2]),n(t(n(v(b[1],A[0]),v(-A[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),A[2]))),_[3]),t(n(t(n(v(w[1],_[0]),v(-_[1],w[0])),b[2]),n(t(n(v(b[1],_[0]),v(-_[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),_[2]))),-A[3]))))),D=n(n(n(t(n(t(n(v(A[1],I[0]),v(-I[1],A[0])),_[2]),n(t(n(v(_[1],I[0]),v(-I[1],_[0])),-A[2]),t(n(v(_[1],A[0]),v(-A[1],_[0])),I[2]))),b[3]),t(n(t(n(v(A[1],I[0]),v(-I[1],A[0])),b[2]),n(t(n(v(b[1],I[0]),v(-I[1],b[0])),-A[2]),t(n(v(b[1],A[0]),v(-A[1],b[0])),I[2]))),-_[3])),n(t(n(t(n(v(_[1],I[0]),v(-I[1],_[0])),b[2]),n(t(n(v(b[1],I[0]),v(-I[1],b[0])),-_[2]),t(n(v(b[1],_[0]),v(-_[1],b[0])),I[2]))),A[3]),t(n(t(n(v(_[1],A[0]),v(-A[1],_[0])),b[2]),n(t(n(v(b[1],A[0]),v(-A[1],b[0])),-_[2]),t(n(v(b[1],_[0]),v(-_[1],b[0])),A[2]))),-I[3]))),n(n(t(n(t(n(v(_[1],I[0]),v(-I[1],_[0])),w[2]),n(t(n(v(w[1],I[0]),v(-I[1],w[0])),-_[2]),t(n(v(w[1],_[0]),v(-_[1],w[0])),I[2]))),b[3]),t(n(t(n(v(_[1],I[0]),v(-I[1],_[0])),b[2]),n(t(n(v(b[1],I[0]),v(-I[1],b[0])),-_[2]),t(n(v(b[1],_[0]),v(-_[1],b[0])),I[2]))),-w[3])),n(t(n(t(n(v(w[1],I[0]),v(-I[1],w[0])),b[2]),n(t(n(v(b[1],I[0]),v(-I[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),I[2]))),_[3]),t(n(t(n(v(w[1],_[0]),v(-_[1],w[0])),b[2]),n(t(n(v(b[1],_[0]),v(-_[1],b[0])),-w[2]),t(n(v(b[1],w[0]),v(-w[1],b[0])),_[2]))),-I[3])))),N=P(C,D);return N[N.length-1]}}function x(n){var v=n===3?a:n===4?u:c;return v(o,i,s,h)}var d=x(3),M=x(4),S=[function(){return 0},function(){return 0},function(v,t){return t[0]-v[0]},function(v,t,P){var B=(v[1]-P[1])*(t[0]-P[0]),b=(v[0]-P[0])*(t[1]-P[1]),w=B-b,_;if(B>0){if(b<=0)return w;_=B+b}else if(B<0){if(b>=0)return w;_=-(B+b)}else return w;var A=p*_;return w>=A||w<=-A?w:d(v,t,P)},function(v,t,P,B){var b=v[0]-B[0],w=t[0]-B[0],_=P[0]-B[0],A=v[1]-B[1],I=t[1]-B[1],C=P[1]-B[1],D=v[2]-B[2],N=t[2]-B[2],R=P[2]-B[2],z=w*C,L=_*I,Q=_*A,F=b*C,V=b*I,k=w*A,$=D*(z-L)+N*(Q-F)+R*(V-k),H=(Math.abs(z)+Math.abs(L))*Math.abs(D)+(Math.abs(Q)+Math.abs(F))*Math.abs(N)+(Math.abs(V)+Math.abs(k))*Math.abs(R),et=y*H;return $>et||-$>et?$:M(v,t,P,B)}];function E(n){var v=S[n.length];return v||(v=S[n.length]=x(n.length)),v.apply(void 0,n)}function T(n,v,t,P,B,b,w){return function(A,I,C,D,N){switch(arguments.length){case 0:case 1:return 0;case 2:return P(A,I);case 3:return B(A,I,C);case 4:return b(A,I,C,D);case 5:return w(A,I,C,D,N)}for(var R=new Array(arguments.length),z=0;z<arguments.length;++z)R[z]=arguments[z];return n(R)}}function e(){for(;S.length<=f;)S.push(x(S.length));r.exports=T.apply(void 0,[E].concat(S));for(var n=0;n<=f;++n)r.exports[n]=S[n]}e()}}),Co=dt({"node_modules/cdt2d/lib/monotone.js"(l,r){var i=se(),o=Po()[3],s=0,h=1,f=2;r.exports=M;function g(S,E,T,e,n){this.a=S,this.b=E,this.idx=T,this.lowerIds=e,this.upperIds=n}function p(S,E,T,e){this.a=S,this.b=E,this.type=T,this.idx=e}function y(S,E){var T=S.a[0]-E.a[0]||S.a[1]-E.a[1]||S.type-E.type;return T||S.type!==s&&(T=o(S.a,S.b,E.b),T)?T:S.idx-E.idx}function a(S,E){return o(S.a,S.b,E)}function u(S,E,T,e,n){for(var v=i.lt(E,e,a),t=i.gt(E,e,a),P=v;P<t;++P){for(var B=E[P],b=B.lowerIds,_=b.length;_>1&&o(T[b[_-2]],T[b[_-1]],e)>0;)S.push([b[_-1],b[_-2],n]),_-=1;b.length=_,b.push(n);for(var w=B.upperIds,_=w.length;_>1&&o(T[w[_-2]],T[w[_-1]],e)<0;)S.push([w[_-2],w[_-1],n]),_-=1;w.length=_,w.push(n)}}function c(S,E){var T;return S.a[0]<E.a[0]?T=o(S.a,S.b,E.a):T=o(E.b,E.a,S.a),T||(E.b[0]<S.b[0]?T=o(S.a,S.b,E.b):T=o(E.b,E.a,S.b),T||S.idx-E.idx)}function x(S,E,T){var e=i.le(S,T,c),n=S[e],v=n.upperIds,t=v[v.length-1];n.upperIds=[t],S.splice(e+1,0,new g(T.a,T.b,T.idx,[t],v))}function d(S,E,T){var e=T.a;T.a=T.b,T.b=e;var n=i.eq(S,T,c),v=S[n],t=S[n-1];t.upperIds=v.upperIds,S.splice(n,1)}function M(S,E){for(var T=S.length,e=E.length,n=[],v=0;v<T;++v)n.push(new p(S[v],null,s,v));for(var v=0;v<e;++v){var t=E[v],P=S[t[0]],B=S[t[1]];P[0]<B[0]?n.push(new p(P,B,f,v),new p(B,P,h,v)):P[0]>B[0]&&n.push(new p(B,P,f,v),new p(P,B,h,v))}n.sort(y);for(var b=n[0].a[0]-(1+Math.abs(n[0].a[0]))*Math.pow(2,-52),w=[new g([b,1],[b,0],-1,[],[])],_=[],v=0,A=n.length;v<A;++v){var I=n[v],C=I.type;C===s?u(_,w,S,I.a,I.idx):C===f?x(w,S,I):d(w,S,I)}return _}}}),Do=dt({"node_modules/cdt2d/lib/triangulation.js"(l,r){var i=se();r.exports=f;function o(g,p){this.stars=g,this.edges=p}var s=o.prototype;function h(g,p,y){for(var a=1,u=g.length;a<u;a+=2)if(g[a-1]===p&&g[a]===y){g[a-1]=g[u-2],g[a]=g[u-1],g.length=u-2;return}}s.isConstraint=(function(){var g=[0,0];function p(y,a){return y[0]-a[0]||y[1]-a[1]}return function(y,a){return g[0]=Math.min(y,a),g[1]=Math.max(y,a),i.eq(this.edges,g,p)>=0}})(),s.removeTriangle=function(g,p,y){var a=this.stars;h(a[g],p,y),h(a[p],y,g),h(a[y],g,p)},s.addTriangle=function(g,p,y){var a=this.stars;a[g].push(p,y),a[p].push(y,g),a[y].push(g,p)},s.opposite=function(g,p){for(var y=this.stars[p],a=1,u=y.length;a<u;a+=2)if(y[a]===g)return y[a-1];return-1},s.flip=function(g,p){var y=this.opposite(g,p),a=this.opposite(p,g);this.removeTriangle(g,p,y),this.removeTriangle(p,g,a),this.addTriangle(g,a,y),this.addTriangle(p,y,a)},s.edges=function(){for(var g=this.stars,p=[],y=0,a=g.length;y<a;++y)for(var u=g[y],c=0,x=u.length;c<x;c+=2)p.push([u[c],u[c+1]]);return p},s.cells=function(){for(var g=this.stars,p=[],y=0,a=g.length;y<a;++y)for(var u=g[y],c=0,x=u.length;c<x;c+=2){var d=u[c],M=u[c+1];y<Math.min(d,M)&&p.push([y,d,M])}return p};function f(g,p){for(var y=new Array(g),a=0;a<g;++a)y[a]=[];return new o(y,p)}}}),No=dt({"node_modules/robust-in-sphere/in-sphere.js"(l,r){var i=Ge(),o=Qr(),s=ti(),h=mr(),f=6;function g(e){var n=e===3?u:e===4?c:e===5?x:d;return n(o,s,i,h)}function p(){return 0}function y(){return 0}function a(){return 0}function u(e,n,v,t){function P(B,b,w){var _=v(B[0],B[0]),A=t(_,b[0]),I=t(_,w[0]),C=v(b[0],b[0]),D=t(C,B[0]),N=t(C,w[0]),R=v(w[0],w[0]),z=t(R,B[0]),L=t(R,b[0]),Q=e(n(L,N),n(D,A)),F=n(z,I),V=n(Q,F);return V[V.length-1]}return P}function c(e,n,v,t){function P(B,b,w,_){var A=e(v(B[0],B[0]),v(B[1],B[1])),I=t(A,b[0]),C=t(A,w[0]),D=t(A,_[0]),N=e(v(b[0],b[0]),v(b[1],b[1])),R=t(N,B[0]),z=t(N,w[0]),L=t(N,_[0]),Q=e(v(w[0],w[0]),v(w[1],w[1])),F=t(Q,B[0]),V=t(Q,b[0]),k=t(Q,_[0]),$=e(v(_[0],_[0]),v(_[1],_[1])),H=t($,B[0]),et=t($,b[0]),q=t($,w[0]),G=e(e(t(n(q,k),b[1]),e(t(n(et,L),-w[1]),t(n(V,z),_[1]))),e(t(n(et,L),B[1]),e(t(n(H,D),-b[1]),t(n(R,I),_[1])))),O=e(e(t(n(q,k),B[1]),e(t(n(H,D),-w[1]),t(n(F,C),_[1]))),e(t(n(V,z),B[1]),e(t(n(F,C),-b[1]),t(n(R,I),w[1])))),X=n(G,O);return X[X.length-1]}return P}function x(e,n,v,t){function P(B,b,w,_,A){var I=e(v(B[0],B[0]),e(v(B[1],B[1]),v(B[2],B[2]))),C=t(I,b[0]),D=t(I,w[0]),N=t(I,_[0]),R=t(I,A[0]),z=e(v(b[0],b[0]),e(v(b[1],b[1]),v(b[2],b[2]))),L=t(z,B[0]),Q=t(z,w[0]),F=t(z,_[0]),V=t(z,A[0]),k=e(v(w[0],w[0]),e(v(w[1],w[1]),v(w[2],w[2]))),$=t(k,B[0]),H=t(k,b[0]),et=t(k,_[0]),q=t(k,A[0]),G=e(v(_[0],_[0]),e(v(_[1],_[1]),v(_[2],_[2]))),O=t(G,B[0]),X=t(G,b[0]),W=t(G,w[0]),St=t(G,A[0]),J=e(v(A[0],A[0]),e(v(A[1],A[1]),v(A[2],A[2]))),j=t(J,B[0]),Y=t(J,b[0]),Z=t(J,w[0]),K=t(J,_[0]),Xt=e(e(e(t(e(t(n(K,St),w[1]),e(t(n(Z,q),-_[1]),t(n(W,et),A[1]))),b[2]),e(t(e(t(n(K,St),b[1]),e(t(n(Y,V),-_[1]),t(n(X,F),A[1]))),-w[2]),t(e(t(n(Z,q),b[1]),e(t(n(Y,V),-w[1]),t(n(H,Q),A[1]))),_[2]))),e(t(e(t(n(W,et),b[1]),e(t(n(X,F),-w[1]),t(n(H,Q),_[1]))),-A[2]),e(t(e(t(n(K,St),b[1]),e(t(n(Y,V),-_[1]),t(n(X,F),A[1]))),B[2]),t(e(t(n(K,St),B[1]),e(t(n(j,R),-_[1]),t(n(O,N),A[1]))),-b[2])))),e(e(t(e(t(n(Y,V),B[1]),e(t(n(j,R),-b[1]),t(n(L,C),A[1]))),_[2]),e(t(e(t(n(X,F),B[1]),e(t(n(O,N),-b[1]),t(n(L,C),_[1]))),-A[2]),t(e(t(n(W,et),b[1]),e(t(n(X,F),-w[1]),t(n(H,Q),_[1]))),B[2]))),e(t(e(t(n(W,et),B[1]),e(t(n(O,N),-w[1]),t(n($,D),_[1]))),-b[2]),e(t(e(t(n(X,F),B[1]),e(t(n(O,N),-b[1]),t(n(L,C),_[1]))),w[2]),t(e(t(n(H,Q),B[1]),e(t(n($,D),-b[1]),t(n(L,C),w[1]))),-_[2]))))),tt=e(e(e(t(e(t(n(K,St),w[1]),e(t(n(Z,q),-_[1]),t(n(W,et),A[1]))),B[2]),t(e(t(n(K,St),B[1]),e(t(n(j,R),-_[1]),t(n(O,N),A[1]))),-w[2])),e(t(e(t(n(Z,q),B[1]),e(t(n(j,R),-w[1]),t(n($,D),A[1]))),_[2]),t(e(t(n(W,et),B[1]),e(t(n(O,N),-w[1]),t(n($,D),_[1]))),-A[2]))),e(e(t(e(t(n(Z,q),b[1]),e(t(n(Y,V),-w[1]),t(n(H,Q),A[1]))),B[2]),t(e(t(n(Z,q),B[1]),e(t(n(j,R),-w[1]),t(n($,D),A[1]))),-b[2])),e(t(e(t(n(Y,V),B[1]),e(t(n(j,R),-b[1]),t(n(L,C),A[1]))),w[2]),t(e(t(n(H,Q),B[1]),e(t(n($,D),-b[1]),t(n(L,C),w[1]))),-A[2])))),m=n(Xt,tt);return m[m.length-1]}return P}function d(e,n,v,t){function P(B,b,w,_,A,I){var C=e(e(v(B[0],B[0]),v(B[1],B[1])),e(v(B[2],B[2]),v(B[3],B[3]))),D=t(C,b[0]),N=t(C,w[0]),R=t(C,_[0]),z=t(C,A[0]),L=t(C,I[0]),Q=e(e(v(b[0],b[0]),v(b[1],b[1])),e(v(b[2],b[2]),v(b[3],b[3]))),F=t(Q,B[0]),V=t(Q,w[0]),k=t(Q,_[0]),$=t(Q,A[0]),H=t(Q,I[0]),et=e(e(v(w[0],w[0]),v(w[1],w[1])),e(v(w[2],w[2]),v(w[3],w[3]))),q=t(et,B[0]),G=t(et,b[0]),O=t(et,_[0]),X=t(et,A[0]),W=t(et,I[0]),St=e(e(v(_[0],_[0]),v(_[1],_[1])),e(v(_[2],_[2]),v(_[3],_[3]))),J=t(St,B[0]),j=t(St,b[0]),Y=t(St,w[0]),Z=t(St,A[0]),K=t(St,I[0]),Xt=e(e(v(A[0],A[0]),v(A[1],A[1])),e(v(A[2],A[2]),v(A[3],A[3]))),tt=t(Xt,B[0]),m=t(Xt,b[0]),rt=t(Xt,w[0]),it=t(Xt,_[0]),ot=t(Xt,I[0]),vn=e(e(v(I[0],I[0]),v(I[1],I[1])),e(v(I[2],I[2]),v(I[3],I[3]))),st=t(vn,B[0]),at=t(vn,b[0]),ct=t(vn,w[0]),lt=t(vn,_[0]),ut=t(vn,A[0]),oi=e(e(e(t(e(e(t(e(t(n(ut,ot),_[1]),e(t(n(lt,K),-A[1]),t(n(it,Z),I[1]))),w[2]),t(e(t(n(ut,ot),w[1]),e(t(n(ct,W),-A[1]),t(n(rt,X),I[1]))),-_[2])),e(t(e(t(n(lt,K),w[1]),e(t(n(ct,W),-_[1]),t(n(Y,O),I[1]))),A[2]),t(e(t(n(it,Z),w[1]),e(t(n(rt,X),-_[1]),t(n(Y,O),A[1]))),-I[2]))),b[3]),e(t(e(e(t(e(t(n(ut,ot),_[1]),e(t(n(lt,K),-A[1]),t(n(it,Z),I[1]))),b[2]),t(e(t(n(ut,ot),b[1]),e(t(n(at,H),-A[1]),t(n(m,$),I[1]))),-_[2])),e(t(e(t(n(lt,K),b[1]),e(t(n(at,H),-_[1]),t(n(j,k),I[1]))),A[2]),t(e(t(n(it,Z),b[1]),e(t(n(m,$),-_[1]),t(n(j,k),A[1]))),-I[2]))),-w[3]),t(e(e(t(e(t(n(ut,ot),w[1]),e(t(n(ct,W),-A[1]),t(n(rt,X),I[1]))),b[2]),t(e(t(n(ut,ot),b[1]),e(t(n(at,H),-A[1]),t(n(m,$),I[1]))),-w[2])),e(t(e(t(n(ct,W),b[1]),e(t(n(at,H),-w[1]),t(n(G,V),I[1]))),A[2]),t(e(t(n(rt,X),b[1]),e(t(n(m,$),-w[1]),t(n(G,V),A[1]))),-I[2]))),_[3]))),e(e(t(e(e(t(e(t(n(lt,K),w[1]),e(t(n(ct,W),-_[1]),t(n(Y,O),I[1]))),b[2]),t(e(t(n(lt,K),b[1]),e(t(n(at,H),-_[1]),t(n(j,k),I[1]))),-w[2])),e(t(e(t(n(ct,W),b[1]),e(t(n(at,H),-w[1]),t(n(G,V),I[1]))),_[2]),t(e(t(n(Y,O),b[1]),e(t(n(j,k),-w[1]),t(n(G,V),_[1]))),-I[2]))),-A[3]),t(e(e(t(e(t(n(it,Z),w[1]),e(t(n(rt,X),-_[1]),t(n(Y,O),A[1]))),b[2]),t(e(t(n(it,Z),b[1]),e(t(n(m,$),-_[1]),t(n(j,k),A[1]))),-w[2])),e(t(e(t(n(rt,X),b[1]),e(t(n(m,$),-w[1]),t(n(G,V),A[1]))),_[2]),t(e(t(n(Y,O),b[1]),e(t(n(j,k),-w[1]),t(n(G,V),_[1]))),-A[2]))),I[3])),e(t(e(e(t(e(t(n(ut,ot),_[1]),e(t(n(lt,K),-A[1]),t(n(it,Z),I[1]))),b[2]),t(e(t(n(ut,ot),b[1]),e(t(n(at,H),-A[1]),t(n(m,$),I[1]))),-_[2])),e(t(e(t(n(lt,K),b[1]),e(t(n(at,H),-_[1]),t(n(j,k),I[1]))),A[2]),t(e(t(n(it,Z),b[1]),e(t(n(m,$),-_[1]),t(n(j,k),A[1]))),-I[2]))),B[3]),t(e(e(t(e(t(n(ut,ot),_[1]),e(t(n(lt,K),-A[1]),t(n(it,Z),I[1]))),B[2]),t(e(t(n(ut,ot),B[1]),e(t(n(st,L),-A[1]),t(n(tt,z),I[1]))),-_[2])),e(t(e(t(n(lt,K),B[1]),e(t(n(st,L),-_[1]),t(n(J,R),I[1]))),A[2]),t(e(t(n(it,Z),B[1]),e(t(n(tt,z),-_[1]),t(n(J,R),A[1]))),-I[2]))),-b[3])))),e(e(e(t(e(e(t(e(t(n(ut,ot),b[1]),e(t(n(at,H),-A[1]),t(n(m,$),I[1]))),B[2]),t(e(t(n(ut,ot),B[1]),e(t(n(st,L),-A[1]),t(n(tt,z),I[1]))),-b[2])),e(t(e(t(n(at,H),B[1]),e(t(n(st,L),-b[1]),t(n(F,D),I[1]))),A[2]),t(e(t(n(m,$),B[1]),e(t(n(tt,z),-b[1]),t(n(F,D),A[1]))),-I[2]))),_[3]),t(e(e(t(e(t(n(lt,K),b[1]),e(t(n(at,H),-_[1]),t(n(j,k),I[1]))),B[2]),t(e(t(n(lt,K),B[1]),e(t(n(st,L),-_[1]),t(n(J,R),I[1]))),-b[2])),e(t(e(t(n(at,H),B[1]),e(t(n(st,L),-b[1]),t(n(F,D),I[1]))),_[2]),t(e(t(n(j,k),B[1]),e(t(n(J,R),-b[1]),t(n(F,D),_[1]))),-I[2]))),-A[3])),e(t(e(e(t(e(t(n(it,Z),b[1]),e(t(n(m,$),-_[1]),t(n(j,k),A[1]))),B[2]),t(e(t(n(it,Z),B[1]),e(t(n(tt,z),-_[1]),t(n(J,R),A[1]))),-b[2])),e(t(e(t(n(m,$),B[1]),e(t(n(tt,z),-b[1]),t(n(F,D),A[1]))),_[2]),t(e(t(n(j,k),B[1]),e(t(n(J,R),-b[1]),t(n(F,D),_[1]))),-A[2]))),I[3]),t(e(e(t(e(t(n(lt,K),w[1]),e(t(n(ct,W),-_[1]),t(n(Y,O),I[1]))),b[2]),t(e(t(n(lt,K),b[1]),e(t(n(at,H),-_[1]),t(n(j,k),I[1]))),-w[2])),e(t(e(t(n(ct,W),b[1]),e(t(n(at,H),-w[1]),t(n(G,V),I[1]))),_[2]),t(e(t(n(Y,O),b[1]),e(t(n(j,k),-w[1]),t(n(G,V),_[1]))),-I[2]))),B[3]))),e(e(t(e(e(t(e(t(n(lt,K),w[1]),e(t(n(ct,W),-_[1]),t(n(Y,O),I[1]))),B[2]),t(e(t(n(lt,K),B[1]),e(t(n(st,L),-_[1]),t(n(J,R),I[1]))),-w[2])),e(t(e(t(n(ct,W),B[1]),e(t(n(st,L),-w[1]),t(n(q,N),I[1]))),_[2]),t(e(t(n(Y,O),B[1]),e(t(n(J,R),-w[1]),t(n(q,N),_[1]))),-I[2]))),-b[3]),t(e(e(t(e(t(n(lt,K),b[1]),e(t(n(at,H),-_[1]),t(n(j,k),I[1]))),B[2]),t(e(t(n(lt,K),B[1]),e(t(n(st,L),-_[1]),t(n(J,R),I[1]))),-b[2])),e(t(e(t(n(at,H),B[1]),e(t(n(st,L),-b[1]),t(n(F,D),I[1]))),_[2]),t(e(t(n(j,k),B[1]),e(t(n(J,R),-b[1]),t(n(F,D),_[1]))),-I[2]))),w[3])),e(t(e(e(t(e(t(n(ct,W),b[1]),e(t(n(at,H),-w[1]),t(n(G,V),I[1]))),B[2]),t(e(t(n(ct,W),B[1]),e(t(n(st,L),-w[1]),t(n(q,N),I[1]))),-b[2])),e(t(e(t(n(at,H),B[1]),e(t(n(st,L),-b[1]),t(n(F,D),I[1]))),w[2]),t(e(t(n(G,V),B[1]),e(t(n(q,N),-b[1]),t(n(F,D),w[1]))),-I[2]))),-_[3]),t(e(e(t(e(t(n(Y,O),b[1]),e(t(n(j,k),-w[1]),t(n(G,V),_[1]))),B[2]),t(e(t(n(Y,O),B[1]),e(t(n(J,R),-w[1]),t(n(q,N),_[1]))),-b[2])),e(t(e(t(n(j,k),B[1]),e(t(n(J,R),-b[1]),t(n(F,D),_[1]))),w[2]),t(e(t(n(G,V),B[1]),e(t(n(q,N),-b[1]),t(n(F,D),w[1]))),-_[2]))),I[3]))))),si=e(e(e(t(e(e(t(e(t(n(ut,ot),_[1]),e(t(n(lt,K),-A[1]),t(n(it,Z),I[1]))),w[2]),t(e(t(n(ut,ot),w[1]),e(t(n(ct,W),-A[1]),t(n(rt,X),I[1]))),-_[2])),e(t(e(t(n(lt,K),w[1]),e(t(n(ct,W),-_[1]),t(n(Y,O),I[1]))),A[2]),t(e(t(n(it,Z),w[1]),e(t(n(rt,X),-_[1]),t(n(Y,O),A[1]))),-I[2]))),B[3]),e(t(e(e(t(e(t(n(ut,ot),_[1]),e(t(n(lt,K),-A[1]),t(n(it,Z),I[1]))),B[2]),t(e(t(n(ut,ot),B[1]),e(t(n(st,L),-A[1]),t(n(tt,z),I[1]))),-_[2])),e(t(e(t(n(lt,K),B[1]),e(t(n(st,L),-_[1]),t(n(J,R),I[1]))),A[2]),t(e(t(n(it,Z),B[1]),e(t(n(tt,z),-_[1]),t(n(J,R),A[1]))),-I[2]))),-w[3]),t(e(e(t(e(t(n(ut,ot),w[1]),e(t(n(ct,W),-A[1]),t(n(rt,X),I[1]))),B[2]),t(e(t(n(ut,ot),B[1]),e(t(n(st,L),-A[1]),t(n(tt,z),I[1]))),-w[2])),e(t(e(t(n(ct,W),B[1]),e(t(n(st,L),-w[1]),t(n(q,N),I[1]))),A[2]),t(e(t(n(rt,X),B[1]),e(t(n(tt,z),-w[1]),t(n(q,N),A[1]))),-I[2]))),_[3]))),e(e(t(e(e(t(e(t(n(lt,K),w[1]),e(t(n(ct,W),-_[1]),t(n(Y,O),I[1]))),B[2]),t(e(t(n(lt,K),B[1]),e(t(n(st,L),-_[1]),t(n(J,R),I[1]))),-w[2])),e(t(e(t(n(ct,W),B[1]),e(t(n(st,L),-w[1]),t(n(q,N),I[1]))),_[2]),t(e(t(n(Y,O),B[1]),e(t(n(J,R),-w[1]),t(n(q,N),_[1]))),-I[2]))),-A[3]),t(e(e(t(e(t(n(it,Z),w[1]),e(t(n(rt,X),-_[1]),t(n(Y,O),A[1]))),B[2]),t(e(t(n(it,Z),B[1]),e(t(n(tt,z),-_[1]),t(n(J,R),A[1]))),-w[2])),e(t(e(t(n(rt,X),B[1]),e(t(n(tt,z),-w[1]),t(n(q,N),A[1]))),_[2]),t(e(t(n(Y,O),B[1]),e(t(n(J,R),-w[1]),t(n(q,N),_[1]))),-A[2]))),I[3])),e(t(e(e(t(e(t(n(ut,ot),w[1]),e(t(n(ct,W),-A[1]),t(n(rt,X),I[1]))),b[2]),t(e(t(n(ut,ot),b[1]),e(t(n(at,H),-A[1]),t(n(m,$),I[1]))),-w[2])),e(t(e(t(n(ct,W),b[1]),e(t(n(at,H),-w[1]),t(n(G,V),I[1]))),A[2]),t(e(t(n(rt,X),b[1]),e(t(n(m,$),-w[1]),t(n(G,V),A[1]))),-I[2]))),B[3]),t(e(e(t(e(t(n(ut,ot),w[1]),e(t(n(ct,W),-A[1]),t(n(rt,X),I[1]))),B[2]),t(e(t(n(ut,ot),B[1]),e(t(n(st,L),-A[1]),t(n(tt,z),I[1]))),-w[2])),e(t(e(t(n(ct,W),B[1]),e(t(n(st,L),-w[1]),t(n(q,N),I[1]))),A[2]),t(e(t(n(rt,X),B[1]),e(t(n(tt,z),-w[1]),t(n(q,N),A[1]))),-I[2]))),-b[3])))),e(e(e(t(e(e(t(e(t(n(ut,ot),b[1]),e(t(n(at,H),-A[1]),t(n(m,$),I[1]))),B[2]),t(e(t(n(ut,ot),B[1]),e(t(n(st,L),-A[1]),t(n(tt,z),I[1]))),-b[2])),e(t(e(t(n(at,H),B[1]),e(t(n(st,L),-b[1]),t(n(F,D),I[1]))),A[2]),t(e(t(n(m,$),B[1]),e(t(n(tt,z),-b[1]),t(n(F,D),A[1]))),-I[2]))),w[3]),t(e(e(t(e(t(n(ct,W),b[1]),e(t(n(at,H),-w[1]),t(n(G,V),I[1]))),B[2]),t(e(t(n(ct,W),B[1]),e(t(n(st,L),-w[1]),t(n(q,N),I[1]))),-b[2])),e(t(e(t(n(at,H),B[1]),e(t(n(st,L),-b[1]),t(n(F,D),I[1]))),w[2]),t(e(t(n(G,V),B[1]),e(t(n(q,N),-b[1]),t(n(F,D),w[1]))),-I[2]))),-A[3])),e(t(e(e(t(e(t(n(rt,X),b[1]),e(t(n(m,$),-w[1]),t(n(G,V),A[1]))),B[2]),t(e(t(n(rt,X),B[1]),e(t(n(tt,z),-w[1]),t(n(q,N),A[1]))),-b[2])),e(t(e(t(n(m,$),B[1]),e(t(n(tt,z),-b[1]),t(n(F,D),A[1]))),w[2]),t(e(t(n(G,V),B[1]),e(t(n(q,N),-b[1]),t(n(F,D),w[1]))),-A[2]))),I[3]),t(e(e(t(e(t(n(it,Z),w[1]),e(t(n(rt,X),-_[1]),t(n(Y,O),A[1]))),b[2]),t(e(t(n(it,Z),b[1]),e(t(n(m,$),-_[1]),t(n(j,k),A[1]))),-w[2])),e(t(e(t(n(rt,X),b[1]),e(t(n(m,$),-w[1]),t(n(G,V),A[1]))),_[2]),t(e(t(n(Y,O),b[1]),e(t(n(j,k),-w[1]),t(n(G,V),_[1]))),-A[2]))),B[3]))),e(e(t(e(e(t(e(t(n(it,Z),w[1]),e(t(n(rt,X),-_[1]),t(n(Y,O),A[1]))),B[2]),t(e(t(n(it,Z),B[1]),e(t(n(tt,z),-_[1]),t(n(J,R),A[1]))),-w[2])),e(t(e(t(n(rt,X),B[1]),e(t(n(tt,z),-w[1]),t(n(q,N),A[1]))),_[2]),t(e(t(n(Y,O),B[1]),e(t(n(J,R),-w[1]),t(n(q,N),_[1]))),-A[2]))),-b[3]),t(e(e(t(e(t(n(it,Z),b[1]),e(t(n(m,$),-_[1]),t(n(j,k),A[1]))),B[2]),t(e(t(n(it,Z),B[1]),e(t(n(tt,z),-_[1]),t(n(J,R),A[1]))),-b[2])),e(t(e(t(n(m,$),B[1]),e(t(n(tt,z),-b[1]),t(n(F,D),A[1]))),_[2]),t(e(t(n(j,k),B[1]),e(t(n(J,R),-b[1]),t(n(F,D),_[1]))),-A[2]))),w[3])),e(t(e(e(t(e(t(n(rt,X),b[1]),e(t(n(m,$),-w[1]),t(n(G,V),A[1]))),B[2]),t(e(t(n(rt,X),B[1]),e(t(n(tt,z),-w[1]),t(n(q,N),A[1]))),-b[2])),e(t(e(t(n(m,$),B[1]),e(t(n(tt,z),-b[1]),t(n(F,D),A[1]))),w[2]),t(e(t(n(G,V),B[1]),e(t(n(q,N),-b[1]),t(n(F,D),w[1]))),-A[2]))),-_[3]),t(e(e(t(e(t(n(Y,O),b[1]),e(t(n(j,k),-w[1]),t(n(G,V),_[1]))),B[2]),t(e(t(n(Y,O),B[1]),e(t(n(J,R),-w[1]),t(n(q,N),_[1]))),-b[2])),e(t(e(t(n(j,k),B[1]),e(t(n(J,R),-b[1]),t(n(F,D),_[1]))),w[2]),t(e(t(n(G,V),B[1]),e(t(n(q,N),-b[1]),t(n(F,D),w[1]))),-_[2]))),A[3]))))),je=n(oi,si);return je[je.length-1]}return P}var M=[p,y,a];function S(e){var n=M[e.length];return n||(n=M[e.length]=g(e.length)),n.apply(void 0,e)}function E(e,n,v,t,P,B,b,w){function _(A,I,C,D,N,R){switch(arguments.length){case 0:case 1:return 0;case 2:return t(A,I);case 3:return P(A,I,C);case 4:return B(A,I,C,D);case 5:return b(A,I,C,D,N);case 6:return w(A,I,C,D,N,R)}for(var z=new Array(arguments.length),L=0;L<arguments.length;++L)z[L]=arguments[L];return e(z)}return _}function T(){for(;M.length<=f;)M.push(g(M.length));r.exports=E.apply(void 0,[S].concat(M));for(var e=0;e<=f;++e)r.exports[e]=M[e]}T()}}),Ro=dt({"node_modules/cdt2d/lib/delaunay.js"(l,r){var i=No()[4];se(),r.exports=s;function o(h,f,g,p,y,a){var u=f.opposite(p,y);if(!(u<0)){if(y<p){var c=p;p=y,y=c,c=a,a=u,u=c}f.isConstraint(p,y)||i(h[p],h[y],h[a],h[u])<0&&g.push(p,y)}}function s(h,f){for(var g=[],p=h.length,y=f.stars,a=0;a<p;++a)for(var u=y[a],c=1;c<u.length;c+=2){var x=u[c];if(!(x<a)&&!f.isConstraint(a,x)){for(var d=u[c-1],M=-1,S=1;S<u.length;S+=2)if(u[S-1]===x){M=u[S];break}M<0||i(h[a],h[x],h[d],h[M])<0&&g.push(a,x)}}for(;g.length>0;){for(var x=g.pop(),a=g.pop(),d=-1,M=-1,u=y[a],E=1;E<u.length;E+=2){var T=u[E-1],e=u[E];T===x?M=e:e===x&&(d=T)}d<0||M<0||i(h[a],h[x],h[d],h[M])>=0||(f.flip(a,x),o(h,f,g,d,a,M),o(h,f,g,a,M,d),o(h,f,g,M,x,d),o(h,f,g,x,d,M))}}}}),zo=dt({"node_modules/cdt2d/lib/filter.js"(l,r){var i=se();r.exports=p;function o(y,a,u,c,x,d,M){this.cells=y,this.neighbor=a,this.flags=c,this.constraint=u,this.active=x,this.next=d,this.boundary=M}var s=o.prototype;function h(y,a){return y[0]-a[0]||y[1]-a[1]||y[2]-a[2]}s.locate=(function(){var y=[0,0,0];return function(a,u,c){var x=a,d=u,M=c;return u<c?u<a&&(x=u,d=c,M=a):c<a&&(x=c,d=a,M=u),x<0?-1:(y[0]=x,y[1]=d,y[2]=M,i.eq(this.cells,y,h))}})();function f(y,a){for(var u=y.cells(),c=u.length,x=0;x<c;++x){var d=u[x],M=d[0],S=d[1],E=d[2];S<E?S<M&&(d[0]=S,d[1]=E,d[2]=M):E<M&&(d[0]=E,d[1]=M,d[2]=S)}u.sort(h);for(var T=new Array(c),x=0;x<T.length;++x)T[x]=0;var e=[],n=[],v=new Array(3*c),t=new Array(3*c),P=null;a&&(P=[]);for(var B=new o(u,v,t,T,e,n,P),x=0;x<c;++x)for(var d=u[x],b=0;b<3;++b){var M=d[b],S=d[(b+1)%3],w=v[3*x+b]=B.locate(S,M,y.opposite(S,M)),_=t[3*x+b]=y.isConstraint(M,S);w<0&&(_?n.push(x):(e.push(x),T[x]=1),a&&P.push([S,M,-1]))}return B}function g(y,a,u){for(var c=0,x=0;x<y.length;++x)a[x]===u&&(y[c++]=y[x]);return y.length=c,y}function p(y,a,u){var c=f(y,u);if(a===0)return u?c.cells.concat(c.boundary):c.cells;for(var x=1,d=c.active,M=c.next,S=c.flags,E=c.cells,T=c.constraint,e=c.neighbor;d.length>0||M.length>0;){for(;d.length>0;){var n=d.pop();if(S[n]!==-x){S[n]=x,E[n];for(var v=0;v<3;++v){var t=e[3*n+v];t>=0&&S[t]===0&&(T[3*n+v]?M.push(t):(d.push(t),S[t]=x))}}}var P=M;M=d,d=P,M.length=0,x=-x}var B=g(E,S,a);return u?B.concat(c.boundary):B}}}),Lo=dt({"node_modules/cdt2d/cdt2d.js"(l,r){var i=Co(),o=Do(),s=Ro(),h=zo();r.exports=a;function f(u){return[Math.min(u[0],u[1]),Math.max(u[0],u[1])]}function g(u,c){return u[0]-c[0]||u[1]-c[1]}function p(u){return u.map(f).sort(g)}function y(u,c,x){return c in u?u[c]:x}function a(u,c,x){Array.isArray(c)?(x=x||{},c=c||[]):(x=c||{},c=[]);var d=!!y(x,"delaunay",!0),M=!!y(x,"interior",!0),S=!!y(x,"exterior",!0),E=!!y(x,"infinity",!1);if(!M&&!S||u.length===0)return[];var T=i(u,c);if(d||M!==S||E){for(var e=o(u.length,p(c)),n=0;n<T.length;++n){var v=T[n];e.addTriangle(v[0],v[1],v[2])}return d&&s(u,e),S?M?E?h(e,0,E):e.cells():h(e,1,E):h(e,-1)}else return T}}});const Uo=Lo(),Ar=1e-16,Fo=1e-16,Jt=new U,_r=new U,Br=new yn(()=>({param:0,index:0})),Vo=new yn(()=>new U);function $o(l,r,i,o){Br.clear(),r.length=0,i.length=0;for(let y=0,a=l.length;y<a;y++){const u=l[y];p(u.start),p(u.end)}for(let y=0,a=l.length;y<a;y++){const u=l[y];for(let c=y+1;c<a;c++){const x=l[c];u.distanceSqToLine3(x,Jt,_r)<Ar*o&&p(_r)}}const s=[];for(let y=0,a=l.length;y<a;y++){s.length=0;const u=l[y];for(let c=0,x=r.length;c<x;c++){const d=r[c],M=u.closestPointToPointParameter(d,!0);if(u.at(M,Jt),d.distanceToSquared(Jt)<Ar*o){const S=Br.getInstance();S.param=M,S.index=c,s.push(S)}}s.sort(g);for(let c=0,x=s.length-1;c<x;c++){const d=s[c].index,M=s[c+1].index;d!==M&&i.push([d,M])}}const h=new Set;let f=0;for(let y=0,a=i.length;y<a;y++){const u=i[y],c=Math.min(u[0],u[1]),x=Math.max(u[0],u[1]),d=c+","+x;h.has(d)||(h.add(d),i[f++]=u)}i.length=f;function g(y,a){return y.param-a.param}function p(y){for(let a=0;a<r.length;a++){const u=r[a];if(y===u||y.distanceToSquared(u)<Fo*o)return a}return r.push(Vo.getInstance().copy(y)),r.length-1}}class Tr{constructor(){this.trianglePool=new yn(()=>new Ht),this.linePool=new yn(()=>new Ut),this.triangles=[],this.triangleIndices=[],this.constrainedEdges=[],this.triangleConnectivity=[],this.normal=new U,this.projOrigin=new U,this.projU=new U,this.projV=new U,this.baseTri=new Ht,this.baseIndices=new Array(3)}initialize(r,i=null,o=null,s=null){this.reset();const{normal:h,baseTri:f,projU:g,projV:p,projOrigin:y,constrainedEdges:a,linePool:u,baseIndices:c}=this;r.getNormal(h),f.copy(r),f.update(),c[0]=i,c[1]=o,c[2]=s,a.length=0;const x=u.getInstance();x.start.copy(f.a),x.end.copy(f.b);const d=u.getInstance();d.start.copy(f.b),d.end.copy(f.c);const M=u.getInstance();M.start.copy(f.c),M.end.copy(f.a),a.push(x,d,M),y.copy(f.a),g.subVectors(f.b,f.a).normalize(),p.crossVectors(h,g).normalize()}addConstraintEdge(r){const{constrainedEdges:i,linePool:o}=this,s=o.getInstance().copy(r);i.push(s)}_to2D(r,i){const{projOrigin:o,projU:s,projV:h}=this;return Jt.subVectors(r,o),i.set(Jt.dot(s),Jt.dot(h),0)}_from2D(r,i,o){const{projOrigin:s,projU:h,projV:f}=this;return o.copy(s).addScaledVector(h,r).addScaledVector(f,i),o}triangulate(){const{triangles:r,trianglePool:i,triangleConnectivity:o,triangleIndices:s,linePool:h,baseTri:f,constrainedEdges:g,baseIndices:p}=this;r.length=0,i.clear();const y=[];for(let E=0,T=g.length;E<T;E++){const e=g[E],n=h.getInstance();this._to2D(e.start,n.start),this._to2D(e.end,n.end),y.push(n)}let a=0;for(let E=0;E<3;E++){const T=this._to2D(f.points[E],Jt);a=Math.max(a,Math.abs(T.x),Math.abs(T.y))}const u=[],c=[];$o(y,u,c,a);const x=[];for(let E=0,T=u.length;E<T;E++){const e=u[E];x.push([e.x,e.y])}const d=Uo(x,c,{exterior:!1}),M=new Map;for(let E=0,T=c.length;E<T;E++){const e=c[E];M.set(`${e[0]}_${e[1]}`,-1),M.set(`${e[1]}_${e[0]}`,-1)}const S=`${p[0]}_${p[1]}_${p[2]}_`;for(let E=0,T=d.length;E<T;E++){const e=d[E],[n,v,t]=e,P=i.getInstance();this._from2D(x[n][0],x[n][1],P.a),this._from2D(x[v][0],x[v][1],P.b),this._from2D(x[t][0],x[t][1],P.c),r.push(P);const B=[];o.push(B);const b=[];s.push(b);for(let w=0;w<3;w++){const _=e[w];b.push(_<3?p[_]:S+_);const A=e[(w+1)%3],I=`${_}_${A}`;if(M.has(I)){const C=M.get(I);C!==-1&&(B.push(C),o[C].push(E))}else{const C=`${A}_${_}`;M.set(C,E)}}}}reset(){this.trianglePool.clear(),this.linePool.clear(),this.triangles.length=0,this.triangleIndices.length=0,this.triangleConnectivity.length=0,this.constrainedEdges.length=0}}class Ir{constructor(){this.coplanarSet=new Map,this.intersectionSet=new Map,this.edgeSet=new Map,this.ids=[]}add(r,i,o=!1){const{intersectionSet:s,coplanarSet:h,ids:f}=this;s.has(r)||(s.set(r,[]),f.push(r)),s.get(r).push(i),o&&(h.has(r)||h.set(r,new Set),h.get(r).add(i))}addIntersectionEdge(r,i){const{edgeSet:o}=this;o.has(r)||o.set(r,new Set),o.get(r).add(i)}getIntersectionEdges(r){return this.edgeSet.get(r)||null}}const Oo=0,ko=1,Ho=2,qo=3,Xo=4,ni=5,ei=6,_e=1e-10,Go=1e-15,Wo=1e-10,jo=1e-10,dr=new Ut,cn=new Ut,Sr=new U,Mr=new U,Er=new U,Be=new ui,gn=new U,re=new U;function Yo(l,r){l.getNormal(gn),r.getNormal(re);const i=gn.dot(re);if(Math.abs(1-Math.abs(i))>=Wo)return!1;const o=gn.dot(l.a),s=gn.dot(r.a);return Math.abs(o-s)<jo}function Pr(l,r,i,o){let s=0,h=1;l.delta(Sr);const f=[r.a,r.b,r.c];for(let g=0;g<3;g++){const p=f[g],y=f[(g+1)%3];Mr.subVectors(y,p),Er.crossVectors(i,Mr),Be.setFromNormalAndCoplanarPoint(Er,p);const a=Be.distanceToPoint(l.start),u=Be.normal.dot(Sr);if(Math.abs(u)<Go){if(a<-_e)return null;continue}const c=-a/u;if(u>0?s=Math.max(s,c):h=Math.min(h,c),s>h+_e)return null}return h-s<_e?null:(l.at(s,o.start),l.at(h,o.end),o)}function Cr(l,r,i){let o=0;l.getNormal(gn),r.getNormal(re);const s=[r.a,r.b,r.c];for(let f=0;f<3;f++){cn.start.copy(s[f]),cn.end.copy(s[(f+1)%3]);const g=Pr(cn,l,gn,dr);g!==null&&(o>=i.length&&i.push(new Ut),i[o].copy(g),o++)}const h=[l.a,l.b,l.c];for(let f=0;f<3;f++){cn.start.copy(h[f]),cn.end.copy(h[(f+1)%3]);const g=Pr(cn,r,re,dr);g!==null&&(o>=i.length&&i.push(new Ut),i[o].copy(g),o++)}return o}const ln=new $e,Dr=new It,Xn=new Ut,Te=[],Gn=new yn(()=>new Ut),un=-1,hn=1,Jn=-2,Qn=2,dn=0,Yt=1,We=2;let mn=null;function Nr(l){mn=l}function ri(l,r,i=null){l.getMidpoint(ln.origin),l.getNormal(ln.direction),i&&(ln.origin.applyMatrix4(i),ln.direction.transformDirection(i));const o=r.raycastFirst(ln,Hr);return!!(o&&ln.direction.dot(o.face.normal)>0)?un:hn}function Zo(l,r){const i=new Ir,o=new Ir;return Gn.clear(),Dr.copy(l.matrixWorld).invert().multiply(r.matrixWorld),l.geometry.boundsTree.bvhcast(r.geometry.boundsTree,Dr,{intersectsTriangles(s,h,f,g){if(!Ee(s)&&!Ee(h)){const y=(Yo(s,h)?Cr(s,h,Te):0)>2;if(y||s.intersectsTriangle(h,Xn,!0)){const u=l.geometry.boundsTree.resolveTriangleIndex(f),c=r.geometry.boundsTree.resolveTriangleIndex(g);if(i.add(u,c,y),o.add(c,u,y),y){const x=Cr(s,h,Te);for(let d=0;d<x;d++){const M=Gn.getInstance().copy(Te[d]);i.addIntersectionEdge(u,M),o.addIntersectionEdge(c,M)}}else{const x=Gn.getInstance().copy(Xn),d=Gn.getInstance().copy(Xn);i.addIntersectionEdge(u,x),o.addIntersectionEdge(c,d)}mn&&(mn.addEdge(Xn),mn.addIntersectingTriangles(f,s,g,h))}}return!1}}),{aIntersections:i,bIntersections:o}}function ii(l,r,i=!1){switch(l){case Oo:if(r===hn||r===Qn&&!i)return Yt;break;case ko:if(i){if(r===un)return dn}else if(r===hn||r===Jn)return Yt;break;case Ho:if(i){if(r===hn||r===Jn)return Yt}else if(r===un)return dn;break;case Xo:if(r===un)return dn;if(r===hn)return Yt;break;case qo:if(r===un||r===Qn&&!i)return Yt;break;case ni:if(!i&&(r===hn||r===Jn))return Yt;break;case ei:if(!i&&(r===un||r===Qn))return Yt;break;default:throw new Error(`Unrecognized CSG operation enum "${l}".`)}return We}class Ko{constructor(r){this.triangle=new Mt().copy(r),this.intersects={}}addTriangle(r,i){this.intersects[r]=new Mt().copy(i)}getIntersectArray(){const r=[],{intersects:i}=this;for(const o in i)r.push(i[o]);return r}}class Rr{constructor(){this.data={}}addTriangleIntersection(r,i,o,s){const{data:h}=this;h[r]||(h[r]=new Ko(i)),h[r].addTriangle(o,s)}getTrianglesAsArray(r=null){const{data:i}=this,o=[];if(r!==null)r in i&&o.push(i[r].triangle);else for(const s in i)o.push(i[s].triangle);return o}getTriangleIndices(){return Object.keys(this.data).map(r=>parseInt(r))}getIntersectionIndices(r){const{data:i}=this;return i[r]?Object.keys(i[r].intersects).map(o=>parseInt(o)):[]}getIntersectionsAsArray(r=null,i=null){const{data:o}=this,s=new Set,h=[],f=g=>{if(o[g])if(i!==null)o[g].intersects[i]&&h.push(o[g].intersects[i]);else{const p=o[g].intersects;for(const y in p)s.has(y)||(s.add(y),h.push(p[y]))}};if(r!==null)f(r);else for(const g in o)f(g);return h}reset(){this.data={}}}class Jo{constructor(){this.enabled=!1,this.triangleIntersectsA=new Rr,this.triangleIntersectsB=new Rr,this.intersectionEdges=[]}addIntersectingTriangles(r,i,o,s){const{triangleIntersectsA:h,triangleIntersectsB:f}=this;h.addTriangleIntersection(r,i,o,s),f.addTriangleIntersection(o,s,r,i)}addEdge(r){this.intersectionEdges.push(r.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Nr(this))}complete(){this.enabled&&Nr(null)}}const Tt=new It,Zt=new It,Bt=new It,Ot=new hi,Pt=new Mt,Kt=new Mt,Ct=new Mt,Vt=new Mt,Qt=[],Nt=[],Wn=new Set,zr=new U,Lr=new U,Ur=new yn(()=>new Mt),Fr=new U,jn=[];function Qo(l,r,i,o,s,h={}){const{useGroups:f=!0}=h,{aIntersections:g,bIntersections:p}=Zo(l,r),y=[];let a=null,u;return u=f?0:-1,$r(l,r,g,i,!1,s,u),Vr(l,r,g,i,!1,o,s,u),i.findIndex(x=>x!==ei&&x!==ni)!==-1&&(s.forEach(x=>x.clearIndexMap()),u=f?l.geometry.groups.length||1:-1,$r(r,l,p,i,!0,s,u),Vr(r,l,p,i,!0,o,s,u)),s.forEach(x=>x.clearIndexMap()),Qt.length=0,{groups:y,materials:a}}function Vr(l,r,i,o,s,h,f,g=0){Tt.copy(r.matrixWorld).invert().multiply(l.matrixWorld),Zt.copy(Tt).invert(),s?Bt.copy(Tt):Bt.identity();const p=Bt.determinant()<0;Ot.getNormalMatrix(Bt).multiplyScalar(p?-1:1);const y=l.geometry.groupIndices,a=l.geometry.index,u=l.geometry.attributes.position,c=r.geometry.boundsTree,x=r.geometry.index,d=r.geometry.attributes.position,M=i.ids;for(let S=0,E=M.length;S<E;S++){const T=M[S],e=g===-1?0:y[T]+g,n=3*T;let v=n+0,t=n+1,P=n+2;a&&(v=a.getX(v),t=a.getX(t),P=a.getX(P)),Pt.a.fromBufferAttribute(u,v),Pt.b.fromBufferAttribute(u,t),Pt.c.fromBufferAttribute(u,P),s&&(Pt.a.applyMatrix4(Tt),Pt.b.applyMatrix4(Tt),Pt.c.applyMatrix4(Tt)),h.reset(),h.initialize(Pt,v,t,P),jn.length=0,Ur.clear(),Pt.getNormal(Lr);const B=i.coplanarSet.get(T);if(B)for(const A of B){const I=3*A;let C=I+0,D=I+1,N=I+2;x&&(C=x.getX(C),D=x.getX(D),N=x.getX(N));const R=Ur.getInstance();R.a.fromBufferAttribute(d,C),R.b.fromBufferAttribute(d,D),R.c.fromBufferAttribute(d,N),s||(R.a.applyMatrix4(Zt),R.b.applyMatrix4(Zt),R.c.applyMatrix4(Zt)),jn.push(R)}if(h.addConstraintEdge){const A=i.getIntersectionEdges(T);if(A)for(const I of A)h.addConstraintEdge(I);h.triangulate()}else{const I=i.intersectionSet.get(T);for(let C=0,D=I.length;C<D;C++){const N=I[C],R=B&&B.has(N),z=3*N;let L=z+0,Q=z+1,F=z+2;x&&(L=x.getX(L),Q=x.getX(Q),F=x.getX(F)),Kt.a.fromBufferAttribute(d,L),Kt.b.fromBufferAttribute(d,Q),Kt.c.fromBufferAttribute(d,F),s||(Kt.a.applyMatrix4(Zt),Kt.b.applyMatrix4(Zt),Kt.c.applyMatrix4(Zt)),h.splitByTriangle(Kt,R)}}const{triangles:b,triangleIndices:w=[],triangleConnectivity:_=[]}=h;for(let A=0,I=f.length;A<I;A++)f[A].initInterpolatedAttributeData(l.geometry,Bt,Ot,v,t,P);Wn.clear();for(let A=0,I=b.length;A<I;A++){if(Wn.has(A))continue;const C=b[A],D=s?null:Tt;let N=null;C.getMidpoint(zr);for(let R=0,z=jn.length;R<z;R++){const L=jn[R];if(L.containsPoint(zr)){L.getNormal(Fr),N=Lr.dot(Fr)>0?Qn:Jn;break}}N===null&&(N=ri(C,c,D)),Qt.length=0,Nt.length=0;for(let R=0,z=o.length;R<z;R++){const L=ii(o[R],N,s);L!==We&&(Qt.push(L),Nt.push(f[R]))}if(Nt.length!==0){const R=[A];for(;R.length>0;){const z=R.pop();if(Wn.has(z))continue;Wn.add(z);const L=w[z];let Q=null,F=null,V=null;L&&(Q=L[0],F=L[1],V=L[2]);const k=b[z];Pt.getBarycoord(k.a,Vt.a),Pt.getBarycoord(k.b,Vt.b),Pt.getBarycoord(k.c,Vt.c);for(let $=0,H=Nt.length;$<H;$++){const et=Nt[$],G=Qt[$]===dn,O=p!==G;et.appendInterpolatedAttributeData(e,Vt.a,Q,O),O?(et.appendInterpolatedAttributeData(e,Vt.c,V,O),et.appendInterpolatedAttributeData(e,Vt.b,F,O)):(et.appendInterpolatedAttributeData(e,Vt.b,F,O),et.appendInterpolatedAttributeData(e,Vt.c,V,O))}}}}}return M.length}function $r(l,r,i,o,s,h,f=0){Tt.copy(r.matrixWorld).invert().multiply(l.matrixWorld),s?Bt.copy(Tt):Bt.identity();const g=Bt.determinant()<0;Ot.getNormalMatrix(Bt).multiplyScalar(g?-1:1);const p=r.geometry.boundsTree,y=l.geometry.groupIndices,a=l.geometry.index,c=l.geometry.attributes.position,x=[],d=l.geometry.halfEdges,M=new Set(i.ids),S=Xe(l.geometry);for(let E=0;E<S&&M.size!==S;E++){if(M.has(E))continue;M.add(E),x.push(E);const T=3*E;let e=T+0,n=T+1,v=T+2;a&&(e=a.getX(e),n=a.getX(n),v=a.getX(v)),Ct.a.fromBufferAttribute(c,e),Ct.b.fromBufferAttribute(c,n),Ct.c.fromBufferAttribute(c,v),s&&(Ct.a.applyMatrix4(Tt),Ct.b.applyMatrix4(Tt),Ct.c.applyMatrix4(Tt));const t=ri(Ct,p,s?null:Tt);Qt.length=0,Nt.length=0;for(let P=0,B=o.length;P<B;P++){const b=ii(o[P],t,s);b!==We&&(Qt.push(b),Nt.push(h[P]))}for(;x.length>0;){const P=x.pop();for(let B=0;B<3;B++){const b=d.getSiblingTriangleIndex(P,B);b!==-1&&!M.has(b)&&(x.push(b),M.add(b))}if(Nt.length!==0){const B=3*P;let b=B+0,w=B+1,_=B+2;a&&(b=a.getX(b),w=a.getX(w),_=a.getX(_));const A=f===-1?0:y[P]+f;if(Ct.a.fromBufferAttribute(c,b),Ct.b.fromBufferAttribute(c,w),Ct.c.fromBufferAttribute(c,_),!Ee(Ct))for(let I=0,C=Nt.length;I<C;I++){const D=Nt[I],z=Qt[I]===dn!==g;D.appendIndexFromGeometry(l.geometry,Bt,Ot,A,b,z),z?(D.appendIndexFromGeometry(l.geometry,Bt,Ot,A,_,z),D.appendIndexFromGeometry(l.geometry,Bt,Ot,A,w,z)):(D.appendIndexFromGeometry(l.geometry,Bt,Ot,A,w,z),D.appendIndexFromGeometry(l.geometry,Bt,Ot,A,_,z))}}}}}function mo(l){return l=~~l,l+4-l%4}class ts{constructor(r,i=500){this.expansionFactor=1.5,this.type=r,this.length=0,this.array=null,this.setSize(i)}setType(r){if(r===this.type)return;if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const i=this.array.buffer;this.array=new r(i),this.type=r}setSize(r){if(this.array&&r===this.array.length)return;const i=this.type,o=Jr()?SharedArrayBuffer:ArrayBuffer,s=new i(new o(mo(r*i.BYTES_PER_ELEMENT)));this.array&&s.set(this.array,0),this.array=s}expand(){const{array:r,expansionFactor:i}=this;this.setSize(r.length*i)}push(...r){let{array:i,length:o}=this;o+r.length>i.length&&(this.expand(),i=this.array);for(let s=0,h=r.length;s<h;s++)i[o+s]=r[s];this.length+=r.length}clear(){this.length=0}}const _t=new U,Ie=new U,de=new U,Se=new U,Yn=new Mn,ns=new Mn,es=new Mn,rs=new Mn;function is(l,r,i,o,s,h=!1,f=!1){return s.set(0,0,0,0).addScaledVector(l,o.x).addScaledVector(r,o.y).addScaledVector(i,o.z),h&&s.normalize(),f&&s.multiplyScalar(-1),s}function Or(l,r,i){switch(r){case 1:i.push(l.x);break;case 2:i.push(l.x,l.y);break;case 3:i.push(l.x,l.y,l.z);break;case 4:i.push(l.x,l.y,l.z,l.w);break}}class Me extends ts{get count(){return this.length/this.itemSize}constructor(...r){super(...r),this.itemSize=1,this.normalized=!1}}class os{constructor(){this.attributeData={},this.groupIndices=[],this.forwardIndexMap=new Map,this.invertedIndexMap=new Map,this.interpolatedFields={}}initFromGeometry(r,i){this.clear();const{attributeData:o}=this,s=r.attributes;for(let h=0,f=i.length;h<f;h++){const g=i[h],p=s[g],y=p.array.constructor;o[g]||(o[g]=new Me(y)),o[g].setType(y),o[g].itemSize=p.itemSize,o[g].normalized=p.normalized}for(const h in o.attributes)i.includes(h)||o.delete(h)}initInterpolatedAttributeData(r,i,o,s,h,f){const{attributeData:g,interpolatedFields:p}=this,{attributes:y}=r;for(const a in g){const u=y[a];if(!u)throw new Error(`CSG Operations: Attribute ${a} not available on geometry.`);let c,x,d;if(a==="position"?(c=Ie.fromBufferAttribute(u,s).applyMatrix4(i),x=de.fromBufferAttribute(u,h).applyMatrix4(i),d=Se.fromBufferAttribute(u,f).applyMatrix4(i)):a==="normal"?(c=Ie.fromBufferAttribute(u,s).applyNormalMatrix(o),x=de.fromBufferAttribute(u,h).applyNormalMatrix(o),d=Se.fromBufferAttribute(u,f).applyNormalMatrix(o)):a==="tangent"?(c=Ie.fromBufferAttribute(u,s).transformDirection(i),x=de.fromBufferAttribute(u,h).transformDirection(i),d=Se.fromBufferAttribute(u,f).transformDirection(i)):(c=ns.fromBufferAttribute(u,s),x=es.fromBufferAttribute(u,h),d=rs.fromBufferAttribute(u,f)),!p[a])p[a]=[c.clone(),x.clone(),d.clone()];else{const M=p[a];M[0].copy(c),M[1].copy(x),M[2].copy(d)}}}appendInterpolatedAttributeData(r,i,o=null,s=!1){const{groupIndices:h,attributeData:f,interpolatedFields:g,forwardIndexMap:p,invertedIndexMap:y}=this;for(;h.length<=r;)h.push(new Me(Uint32Array));const a=s?y:p,u=h[r];if(o!==null&&a.has(o))u.push(a.get(o));else{a.set(o,f.position.count),u.push(f.position.count);for(const c in g){const x=f[c],d=c==="normal"||c==="tangent",M=s&&d,S=x.itemSize,[E,T,e]=g[c];is(E,T,e,i,Yn,d,M),Or(Yn,S,x)}}}appendIndexFromGeometry(r,i,o,s,h,f=!1){const{groupIndices:g,attributeData:p,forwardIndexMap:y,invertedIndexMap:a}=this;for(;g.length<=s;)g.push(new Me(Uint32Array));const u=f?a:y,c=g[s];if(h!==null&&u.has(h))c.push(u.get(h));else{u.set(h,p.position.count),c.push(p.position.count);const{attributes:x}=r;for(const d in p){const M=p[d],S=x[d];if(!S)throw new Error(`CSG Operations: Attribute ${d} not available on geometry.`);const E=S.itemSize;d==="position"?(_t.fromBufferAttribute(S,h).applyMatrix4(i),M.push(_t.x,_t.y,_t.z)):d==="normal"?(_t.fromBufferAttribute(S,h).applyNormalMatrix(o),f&&_t.multiplyScalar(-1),M.push(_t.x,_t.y,_t.z)):d==="tangent"?(_t.fromBufferAttribute(S,h).transformDirection(i),f&&_t.multiplyScalar(-1),M.push(_t.x,_t.y,_t.z)):(Yn.fromBufferAttribute(S,h),Or(Yn,E,M))}}}buildGeometry(r,i){let o=!1;const{groupIndices:s,attributeData:h}=this,{attributes:f,index:g}=r;for(const a in h){const u=h[a],{type:c,itemSize:x,normalized:d,length:M,count:S}=u,E=u.array.buffer;let T=f[a];(!T||T.count<S||T.array.type!==c)&&(T=new te(new c(M),x,d),r.setAttribute(a,T),o=!0),T.array.set(new c(E,0,M),0),T.needsUpdate=!0}const p=s.reduce((a,u)=>u.count+a,0);(!r.index||g.count<p||g.array.type!==Uint32Array)&&(r.setIndex(new te(new Uint32Array(p),1)),o=!0),r.clearGroups();let y=0;for(let a=0,u=Math.min(i.length,s.length);a<u;a++){const{index:c,materialIndex:x}=i[a],{count:d}=s[c],M=s[c].array.buffer;d!==0&&(r.index.array.set(new Uint32Array(M,0,d),y),r.addGroup(y,d,x),y+=d)}r.setDrawRange(0,y),r.boundsTree=null,r.boundingBox=null,r.boundingSphere=null,o&&r.dispose()}clearIndexMap(){this.forwardIndexMap.clear(),this.invertedIndexMap.clear()}clear(){const{groupIndices:r,attributeData:i}=this;this.interpolatedFields={};for(const o in i)i[o].clear();r.forEach(o=>{o.clear()}),this.clearIndexMap()}}function ss(l,r){for(const i in l.attributes)r.includes(i)||(l.deleteAttribute(i),l.dispose());return l}function as(l,r){const i=[];for(let o=0,s=l.length;o<s;o++){const h=l[o],f=r[h.materialIndex];i.push({...h,materialIndex:r.indexOf(f)})}return i}function cs(l,r){const i=[],o=new Map;for(let s=0,h=l.length;s<h;s++){const f=l[s];o.has(f.materialIndex)||(o.set(f.materialIndex,i.length),i.push(r[f.materialIndex])),f.materialIndex=o.get(f.materialIndex)}return i}function ls(l){for(let r=0;r<l.length-1;r++){const i=l[r],o=l[r+1];if(i.materialIndex===o.materialIndex){const s=i.start,h=o.start+o.count;o.start=s,o.count=h-s,l.splice(r,1),r--}}}function kr(l,r){let i=r;return Array.isArray(r)||(i=[],l.forEach(o=>{i[o.materialIndex]=r})),i}class hs{get useCDTClipping(){return this.triangleSplitter instanceof Tr}set useCDTClipping(r){r!==this.useCDTClipping&&(this.triangleSplitter=r?new Tr:new Ze)}constructor(){this.triangleSplitter=new Ze,this.geometryBuilders=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.removeUnusedMaterials=!0,this.debug=new Jo}getGroupRanges(r){return!this.useGroups||r.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:r.groups.map(o=>({...o}))}evaluate(r,i,o,s=new br){let h=!0;if(Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s],h=!1),s.length!==o.length)throw new Error("Evaluator: operations and target array passed as different sizes.");r.prepareGeometry(),i.prepareGeometry();const{triangleSplitter:f,geometryBuilders:g,attributes:p,useGroups:y,consolidateGroups:a,removeUnusedMaterials:u,debug:c}=this;for(;g.length<s.length;)g.push(new os);s.forEach((e,n)=>{g[n].initFromGeometry(r.geometry,p),ss(e.geometry,p)}),c.init(),Qo(r,i,o,f,g,{useGroups:y}),c.complete();const x=this.getGroupRanges(r.geometry),d=kr(x,r.material),M=this.getGroupRanges(i.geometry),S=kr(M,i.material);M.forEach(e=>e.materialIndex+=d.length);const E=[...d,...S];let T=[...x,...M].map((e,n)=>({...e,index:n}));return y?y&&a&&(T=as(T,E),T.sort((e,n)=>e.materialIndex-n.materialIndex)):T=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach((e,n)=>{const v=e.geometry;g[n].buildGeometry(v,T),r.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.updateMatrix(),e.matrixWorld.copy(r.matrixWorld),y?(e.material=E,a&&ls(v.groups),u&&(e.material=cs(v.groups,E))):e.material=E[0]}),h?s:s[0]}evaluateHierarchy(r,i=new br){r.updateMatrixWorld(!0);const o=(h,f)=>{const g=h.children;for(let p=0,y=g.length;p<y;p++){const a=g[p];a.isOperationGroup?o(a,f):f(a)}},s=h=>{const f=h.children;let g=!1;for(let y=0,a=f.length;y<a;y++){const u=f[y];g=s(u)||g}const p=h.isDirty();if(p&&h.markUpdated(),g&&!h.isOperationGroup){let y;return o(h,a=>{y?y=this.evaluate(y,a,a.operation):y=this.evaluate(h,a,a.operation)}),h._cachedGeometry=y.geometry,h._cachedMaterials=y.material,!0}else return g||p};return s(r),i.geometry=r._cachedGeometry,i.material=r._cachedMaterials,i}reset(){this.triangleSplitter.reset()}}export{Oo as A,br as B,Xo as D,hs as E,ni as H,qo as I,ee as M,Ho as R,ko as S,ei as a,ht as b};
